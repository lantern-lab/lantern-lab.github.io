---
title: 2025ç¬¬ä¸‰å±Šæ•°ä¿¡æ¯
slug: 2025-the-3rd-shuxin-cup-qxcuc
url: /post/2025-the-3rd-shuxin-cup-qxcuc.html
date: '2026-01-01 18:16:49+08:00'
lastmod: '2026-01-02 03:11:25+08:00'
toc: true
isCJKLanguage: true
---



# 2025ç¬¬ä¸‰å±Šæ•°ä¿¡æ¯

## æ•°æ®å¤„ç†

èƒŒæ™¯ï¼šéšç€æ•°æ®å®‰å…¨è¡Œä¸šçš„å¤§åŠ›å‘å±•ï¼Œä½ ä½œä¸ºä¸€ååˆšæ¯•ä¸šçš„å¤§å­¦ç”Ÿï¼Œä¹Ÿæ‰“ç®—è¿›å…¥æ•°æ®å®‰å…¨çš„è¡Œä¸šä¹‹ ä¸­ã€‚åœ¨ä¸æ–­çš„ç®€å†æŠ•é€’ä¸‹ï¼Œä½ ç»ˆäºå¦‚æ„¿è¿›å…¥åˆ°ä¸€å®¶ç‰©è”ç½‘å…¬å¸è¿›è¡Œæ•°æ®å®‰å…¨æ–¹å‘çš„å·¥ä½œã€‚åˆšå…¥èŒçš„ç¬¬ä¸€ å¤©ï¼Œä½ å°±æ¥åˆ°äº†ä¸€ç³»åˆ—ä»»åŠ¡ã€‚

### ç®¡ç†å‘˜è´¦å·å¯†ç 

#### é¢˜ç›®

ç¬¬ä¸€å¤©ä¸Šç­çš„ä½ å»æŸ¥çœ‹å…¬å¸çš„æµé‡ç›‘æ§è®°å½•ï¼Œå‘ç°äº†ä¸€ä¸²éå¸¸å¥‡æ€ªçš„æµé‡ä¿¡æ¯ï¼Œä½ ä¸€çœ¼å°±åˆ¤æ–­å‡ºè¿™æ˜¯é»‘å®¢æ”»å‡»æ‰€äº§ç”Ÿçš„æµé‡ï¼Œä½ å‘ä¸Šçº§æŠ¥å‘Šåï¼Œä¸Šçº§è®©ä½ æŸ¥æ¸…é»‘å®¢è·å–äº†ä»€ä¹ˆæ•°æ®ã€‚

[ç­”æ¡ˆæ ‡å‡†] ä½ éœ€è¦æäº¤æ³„éœ²çš„ç®¡ç†å‘˜çš„è´¦å·å¯†ç 

ä¾‹ï¼šç®¡ç†å‘˜è´¦å·å¯†ç ä¸º123/123ï¼Œåˆ™æœ€ç»ˆæäº¤çš„ç­”æ¡ˆä¸ºï¼š123/123

#### è§£ç­”

åœ¨æŠ¥æ–‡é‡Œæ‰¾ç™»å½•æˆåŠŸçš„

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101182231.png)

### å®¶åº­ä½å€

#### é¢˜ç›®

ä¸ä½ äº¤æ¥çš„åŒäº‹ç”±äºå·¥ä½œä¸Šçš„ç–å¿½å°†åŸå…ˆçš„å±…æ°‘ä¿¡æ¯æ–‡ä»¶è¯¯åˆ é™¤äº†ï¼Œä½†æ˜¯ä½ å‘ç°å…¬å¸çš„ç³»ç»Ÿä¸Šä¾æ—§å­˜åœ¨å±…æ°‘çš„ä¿¡æ¯ï¼Œä¸‹è½½åå‘ç°è¿›è¡Œäº†è„±æ•å¤„ç†ï¼Œä½ éœ€è¦åˆ©ç”¨æŠ€æœ¯æ‰‹æ®µå°†å±…æ°‘ä¿¡æ¯å¿«é€Ÿæ•´ç†å‡ºæ¥ã€‚

[ç­”æ¡ˆæ ‡å‡†] ä½ éœ€è¦æäº¤æ‰‹æœºå·ä¸º18896239239çš„å®¶åº­ä½å€

ä¾‹ï¼šæ‰‹æœºå·ä¸º18896239239çš„å®¶åº­ä½å€ä¸ºé’æµ·çœæ²ˆé˜³å¸‚åˆå·å¾è¡—9å·ï¼Œåˆ™æœ€ç»ˆæäº¤çš„ç­”æ¡ˆä¸ºï¼š é’æµ·çœæ²ˆé˜³å¸‚åˆå·å¾è¡—9å·

#### è§£ç­”

å‘ç°è¡¨æ ¼é‡Œéƒ½æ˜¯base64ç¼–ç çš„

æŠŠæ‰‹æœºå·ä¹Ÿbase64ç¼–ç ååœ¨è¡¨æ ¼é‡Œæœç´¢

æŠŠå¯¹åº”çš„å…¶ä»–åˆ—ç”¨baseè§£ç 

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101182430.png)

### æœ€å¤§æ¬¡æ•°

#### é¢˜ç›®

åœ¨å¾—åˆ°å±…æ°‘ä¿¡æ¯ä¹‹åï¼Œé¢†å¯¼è®©ä½ ç»Ÿè®¡ä¸€ä¸‹å±…æ°‘ä¿¡æ¯ä¸­é‡åçš„æ•°é‡ï¼Œæ–¹ä¾¿åç»­çš„å·¥ä½œå¼€å±•ã€‚

[ç­”æ¡ˆæ ‡å‡†] ä½ éœ€è¦ç»Ÿè®¡å‡ºç°é‡åæ¬¡æ•°å‡ºç°æœ€å¤šçš„äººçš„å§“åä»¥åŠå‡ºç°çš„æ¬¡æ•°

ä¾‹ï¼šé‡åæœ€å¤šçš„äººå«å¼ ä¸‰ï¼Œå‡ºç°äº†10æ¬¡ï¼Œåˆ™æœ€ç»ˆæäº¤çš„ç­”æ¡ˆä¸ºï¼šå¼ ä¸‰10

#### è§£ç­”

ç”¨excelè‡ªå¸¦åŠŸèƒ½å¤„ç†ï¼Œç­›é€‰åæŒ‰è®¡æ•°æ’åº

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101182705.png)

å°†ç»“æœbase64è§£ç ï¼Œç­”æ¡ˆæ˜¯åˆ˜çº¢æ¢…

## **æ•°æ®æ³„éœ²**

ç›´æ¥base64è§£ç 

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101182843.png)

## æ•°æ®æ¢å¤æº¯æº

èƒŒæ™¯ï¼šä¸€å®¶ç§‘æŠ€å…¬å¸çš„è¿ç»´äººå‘˜åœ¨æ—¥å¸¸å·¡æŸ¥çš„æ—¶å€™ï¼Œå‘ç°ä¸€å°æœåŠ¡å™¨ä¸Šå‡ºç°äº†å¼‚å¸¸ï¼Œè¿™å°æœåŠ¡å™¨è®°å½•äº†è®¸å¤šé‡è¦çš„èµ„æ–™ï¼Œåˆæ­¥æ’æŸ¥ä¸‹æ¥åå‘ç°æ˜¯é»‘å®¢å…¥ä¾µäº†æœåŠ¡å™¨å¹¶é€šè¿‡æŠ€æœ¯æ‰‹æ®µçªƒå–äº†é‡è¦çš„æ–‡ä»¶èµ„æ–™ã€‚ç°åœ¨å…¬å¸æ‰¾åˆ°ä½ è¿›è¡Œåˆä½œï¼Œè¯·ä½ æ ¹æ®ç³»ç»Ÿè‡ªåŠ¨ä¿å­˜ä¸‹æ¥çš„æ®‹å­˜å†…å®¹æº¯æºæ•´ä¸ªæ”»å‡»è¡Œä¸ºå¹¶æ‰¾åˆ°æ³„éœ²äº†å“ªäº›æ–‡ä»¶èµ„æ–™ã€‚

### æ•°æ®æ¢å¤

#### é¢˜ç›®

é»‘å®¢åœ¨æ”»å‡»æ—¶ï¼Œä¸ºäº†å¯¹å…¬å¸é€ æˆæ›´å¤§çš„ç ´åï¼Œç›´æ¥åˆ é™¤äº†ç£ç›˜ä¸­çš„æ–‡ä»¶ã€‚ä½†å¥½åœ¨ç³»ç»Ÿæœ‰è‡ªåŠ¨çš„ç£ç›˜å¤‡ä»½è®¡åˆ’ï¼Œä¿ç•™äº†ä¸€ä¸ªå¤‡ä»½ç£ç›˜ã€‚è¯·ä½ é€šè¿‡æŠ€æœ¯æ‰‹æ®µï¼Œæ¢å¤å‡ºé»‘å®¢åˆ é™¤çš„æ–‡ä»¶ã€‚

[ç­”æ¡ˆæ ‡å‡†] è¯·æ‰¾å‡ºåˆ é™¤çš„æ–‡ä»¶ä¸­çš„ä¸€ä¸ªåˆåŒæ–‡ä»¶ï¼Œæäº¤åˆåŒç¼–å·ã€‚

ä¾‹ï¼šå¦‚æœåˆåŒç¼–å·ä¸ºflag{xx-xx-xx}ï¼Œåˆ™æœ€ç»ˆæäº¤ç­”æ¡ˆä¸ºï¼šxx-xx-xx

#### è§£ç­”

æŸ¥çœ‹disk.imgæ–‡ä»¶ç±»å‹ï¼Œç”¨testdiskæå–æ–‡ä»¶

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183404.png)

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183440.png)

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183500.png)

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183516.png)

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183541.png)

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183610.png)

å¯ä»¥çœ‹åˆ°æœ‰ä¸‰ä¸ªæ–‡ä»¶ï¼Œæ ¹æ®æç¤ºï¼ŒæŠŠè¿™ä¸‰ä¸ªæ–‡ä»¶éƒ½æå–å‡ºæ¥ã€‚

æˆ‘çš„kaliæ˜¾ç¤ºä¸äº†ä¸­æ–‡ï¼ŒPDFæ–‡ä»¶åå…¶å®æ˜¯â€œå•†ä¸šåˆä½œåˆåŒ.pdfâ€ï¼Œæ‰“å¼€åè·å¾—ç­”æ¡ˆ

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101183757.png)

### æ•°æ®å­˜å‚¨å®‰å…¨

#### é¢˜ç›®

ä½ é€šè¿‡æŠ€æœ¯æ‰‹æ®µæ¢å¤å‡ºé»‘å®¢åˆ é™¤çš„æ–‡ä»¶åï¼Œå‘ç°å­˜åœ¨åŠ å¯†æ–‡ä»¶ï¼Œä½†æ˜¯ç®¡ç†å‘˜å¿˜è®°äº†å¯†é’¥ï¼Œä½†ç»éªŒä¸°å¯Œçš„ä½ çŸ¥é“å¯ä»¥ç»•å¼€éªŒè¯ç›´æ¥è¯»å–åŠ å¯†æ–‡ä»¶ä¸­çš„å†…å®¹ã€‚è¯·ä½ é€šè¿‡æŠ€æœ¯æ‰‹æ®µï¼Œè¯»å–åŠ å¯†å†…å®¹ã€‚

[ç­”æ¡ˆæ ‡å‡†] è¯·è¯»å–åŠ å¯†æ–‡ä»¶ä¸­çš„å¯†ç æœ¬ï¼Œæäº¤å¯†ç æœ¬ä¸­çš„å†…å®¹

ä¾‹ï¼šå¦‚æœå¯†ç æœ¬ä¸­çš„å†…å®¹ä¸ºflag{xxxxxx}ï¼Œåˆ™æœ€ç»ˆæäº¤ç­”æ¡ˆä¸ºï¼šxxxxxx

#### è§£ç­”

ä¸Šé¢˜ä¸­è·å¾—çš„è¿˜æœ‰ä¸€ä¸ªrawæ–‡ä»¶å’Œä¸€ä¸ªdataæ–‡ä»¶ã€‚dataæ–‡ä»¶å¤§å°åˆšå¥½512MBï¼Œæ ¹æ®é¢˜ç›®æç¤ºï¼ŒçŒœæµ‹dataæ–‡ä»¶å°±æ˜¯åŠ å¯†æ–‡ä»¶ã€‚

å…ˆç”¨å†…å­˜å–è¯å·¥å…·è¯»å–rawæ–‡ä»¶ã€‚

**å‘ç‚¹ï¼ï¼ï¼**

è¿™é‡Œæœ‰ä¸ªå‘ç‚¹ï¼Œæˆ‘ç”¨windows.filescanæ‰«æåå‘ç°é‡Œé¢æœ‰ä¸€ä¸ªâ€œå¯†ç æœ¬.txtâ€ï¼Œä½†å°±æ˜¯æå–ä¸å‡ºæ¥ã€‚å…¶å®ç­”æ¡ˆçš„â€œå¯†ç æœ¬.txtâ€åœ¨dataé‡Œï¼Œä¸åœ¨rawé‡Œã€‚

æŸ¥çœ‹è¿›ç¨‹ä¿¡æ¯ï¼Œå‘ç°æœ‰TrueCryptï¼ŒçŒœæµ‹dataæ–‡ä»¶å°±æ˜¯ç”¨å®ƒåŠ å¯†çš„ã€‚

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101184923.png)

è¿™é‡Œä½¿ç”¨volatility2çš„truecryptmasterè„šæœ¬ä»rawæ–‡ä»¶ä¸­æå–å‡ºmasterkeyï¼Œæ³¨æ„volatility2éœ€è¦ç”¨python2ã€‚

```plaintext
python2 "D:\SecSpace\mem\Lovelymem\Tools\volatility2_python\vol.py" -f "C:\Users\33113\Desktop\æ•°ä¿¡æ¯\disk\recovered\WIN-SERVER-PC-20251202-122722.raw" --profile=Win7SP1x64 truecryptmaster -D  "C:\Users\33113\Desktop\æ•°ä¿¡æ¯\disk\recovered"
```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101185225.png)

æ¥ä¸‹æ¥ç”¨è·å–çš„masterkeyè§£å¯†dataï¼Œæ³¨æ„truecryptä¸æ”¯æŒç”¨masterkeyè§£å¯†

Windowså¹³å°å¯ç”¨ä»¥ä¸‹è„šæœ¬è·å–ä¸€ä¸ªè§£å¯†åçš„imgæ–‡ä»¶ï¼Œç„¶åç”¨testdiskæå–é‡Œé¢çš„å†…å®¹

```python
#!/usr/bin/env python3
"""
TrueCrypt è§£å¯†è„šæœ¬ - ä½¿ç”¨ cryptography åº“çš„åŸç”Ÿ XTS å®ç°
è¿™æ˜¯æœ€å¿«çš„ Python å®ç°æ–¹å¼
"""

import os
import sys
import struct
import time
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

def decrypt_truecrypt_fast(encrypted_file, key_file, output_file, offset=256):
    """ä½¿ç”¨ cryptography åº“çš„åŸç”Ÿ XTS è§£å¯† - æé€Ÿç‰ˆæœ¬"""
    print(f"\n=== TrueCrypt è§£å¯†å·¥å…· (æé€Ÿç‰ˆ) ===\n")
    
    start_time = time.time()
    
    # è¯»å– master key
    with open(key_file, 'rb') as f:
        master_key = f.read()
    
    print(f"Master key: {len(master_key)} å­—èŠ‚")
    
    if len(master_key) < 64:
        master_key = master_key + b'\x00' * (64 - len(master_key))
    
    # cryptography çš„ XTS éœ€è¦å®Œæ•´çš„ 64 å­—èŠ‚å¯†é’¥
    # æ ¼å¼: key1 (32 bytes) + key2 (32 bytes)
    # ä½†é¡ºåºä¸ TrueCrypt ç›¸åï¼štweak key åœ¨å‰ï¼Œdata key åœ¨å
    # TrueCrypt: data_key (32) + tweak_key (32)
    # cryptography XTS: key = data_key + tweak_key (ç›¸åŒé¡ºåº)
    
    file_size = os.path.getsize(encrypted_file)
    print(f"æ–‡ä»¶å¤§å°: {file_size / (1024*1024):.2f} MB")
    
    sector_size = 512
    data_offset = offset * sector_size
    data_size = file_size - data_offset
    
    # ä½¿ç”¨ 64 MB å—ä»¥æœ€å¤§åŒ–æ€§èƒ½
    chunk_size = 64 * 1024 * 1024
    total_chunks = (data_size + chunk_size - 1) // chunk_size
    
    print(f"å—å¤§å°: {chunk_size // (1024*1024)} MB")
    print(f"\nå¼€å§‹è§£å¯†...")
    
    with open(encrypted_file, 'rb') as f_in:
        with open(output_file, 'wb') as f_out:
            f_in.seek(data_offset)
            
            current_sector = offset
            processed = 0
            bytes_processed = 0
            
            while True:
                chunk = f_in.read(chunk_size)
                if not chunk:
                    break
                
                # é€æ‰‡åŒºè§£å¯†ï¼ˆXTS çš„ tweak åŸºäºæ‰‡åŒºå·ï¼‰
                decrypted_chunk = bytearray()
                
                for i in range(0, len(chunk), sector_size):
                    sector_data = chunk[i:i + sector_size]
                    if len(sector_data) < sector_size:
                        sector_data = sector_data + b'\x00' * (sector_size - len(sector_data))
                    
                    # åˆ›å»º tweak (128 ä½å°ç«¯åºæ‰‡åŒºå·)
                    tweak = struct.pack('<QQ', current_sector, 0)
                    
                    # ä½¿ç”¨ cryptography çš„ XTS æ¨¡å¼
                    cipher = Cipher(algorithms.AES(master_key), modes.XTS(tweak))
                    decryptor = cipher.decryptor()
                    decrypted_sector = decryptor.update(sector_data) + decryptor.finalize()
                    
                    decrypted_chunk.extend(decrypted_sector)
                    current_sector += 1
                
                f_out.write(decrypted_chunk)
                
                bytes_processed += len(chunk)
                processed += 1
                
                progress = (bytes_processed / data_size) * 100
                elapsed = time.time() - start_time
                speed = (bytes_processed / (1024*1024)) / elapsed if elapsed > 0 else 0
                eta = (data_size - bytes_processed) / (bytes_processed / elapsed) if bytes_processed > 0 else 0
                print(f"è¿›åº¦: {progress:.1f}% | é€Ÿåº¦: {speed:.1f} MB/s | å‰©ä½™: {eta:.0f}s", end='\r')
    
    elapsed = time.time() - start_time
    avg_speed = (data_size / (1024*1024)) / elapsed
    print(f"\n\nâœ“ è§£å¯†å®Œæˆ!")
    print(f"ç”¨æ—¶: {elapsed:.1f} ç§’")
    print(f"å¹³å‡é€Ÿåº¦: {avg_speed:.1f} MB/s")
    print(f"è¾“å‡ºï¿½ï¿½ï¿½ä»¶: {output_file}")
    
    # æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿ
    print(f"\n=== æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿ ===")
    with open(output_file, 'rb') as f:
        header = f.read(4096)
        if header[3:8] == b'NTFS ':
            print("æ£€æµ‹åˆ°: NTFS")
        elif header[3:8] == b'MSDOS':
            print("æ£€æµ‹åˆ°: FAT32/FAT16")
        elif header[3:8] == b'EXFAT':
            print("æ£€æµ‹åˆ°: exFAT")
        elif len(header) > 1082 and header[1080:1082] == b'\x53\xef':
            print("æ£€æµ‹åˆ°: EXT2/3/4")
        else:
            print(f"æ–‡ä»¶å¤´ (hex): {header[:64].hex()}")
            if header[:512] == b'\x00' * 512:
                print("è­¦å‘Š: æ–‡ä»¶å¤´å…¨ä¸ºé›¶ï¼Œå¯èƒ½è§£å¯†å¤±è´¥")

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    encrypted_file = os.path.join(script_dir, 'data')
    key_file = os.path.join(script_dir, '0xfffffa8018ea11a8_master.key')
    output_file = os.path.join(script_dir, 'decrypted_data.img')
    
    if not os.path.exists(encrypted_file):
        print(f"é”™è¯¯: æ‰¾ä¸åˆ° {encrypted_file}")
        sys.exit(1)
    
    if not os.path.exists(key_file):
        print(f"é”™è¯¯: æ‰¾ä¸åˆ° {key_file}")
        sys.exit(1)
    
    decrypt_truecrypt_fast(encrypted_file, key_file, output_file)

if __name__ == '__main__':
    main()

```

Linuxå¹³å°å¯ä»¥åœ¨githubä¸‹è½½[MKDecrypt.py](https://github.com/AmNe5iA/MKDecrypt)ï¼ŒæŠŠdataæŒ‚è½½åˆ°æœ¬åœ°æŸ¥çœ‹

```python
python MKDecrypt.py -X -m /mnt data 0xfffffa8018ea11a8_master.key
```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101185954.png)

### æµé‡åˆ†æï¼ˆæ²¡åšå‡ºæ¥ï¼‰

#### é¢˜ç›®

ä½ åœ¨ç ´è§£å¼€åŠ å¯†æ–‡ä»¶åï¼Œå‘ç°åŠ å¯†æ–‡ä»¶ä¸­å­˜æ”¾ç€ä¸€ä¸ªæµé‡åŒ…ï¼Œé€šè¿‡åˆ†æä½ å‘ç°æµé‡åŒ…ä¸­è®°å½•ç€é»‘å®¢æ”»å‡»æ—¶äº§ç”Ÿçš„æµé‡ä¿¡æ¯ã€‚ä½ éœ€è¦åˆ†ææµé‡åŒ…ï¼Œæ‰¾å‡ºæ³„éœ²çš„å†…å®¹ã€‚

[ç­”æ¡ˆæ ‡å‡†] è¯·è¯»å–æ³„éœ²çš„å†…å®¹ï¼Œæäº¤æ‰‹æœºå·ä¸ºï¼š18316978925çš„å®¶åº­ä½å€ä¿¡æ¯

ä¾‹ï¼šæ‰‹æœºå·18316978925çš„å®¶åº­ä½å€ä¸ºï¼šå››å·çœæˆéƒ½å¸‚é”¦æ±ŸåŒºå­¦åºœè·¯159å·å’Œè°è‹‘23æ ‹5å•å…ƒ22å®¤ï¼Œåˆ™æœ€ç»ˆæäº¤ç­”æ¡ˆä¸ºï¼šå››å·çœæˆéƒ½å¸‚é”¦æ±ŸåŒºå­¦åºœè·¯159å·å’Œè°è‹‘23æ ‹5å•å…ƒ22å®¤

#### è§£ç­”

æµé‡åŒ…å°±æ˜¯ä¸Šé¢˜è·å¾—çš„challenge.zipï¼Œä½†è¿™é¢˜æˆ‘æœªè§£å‡ºã€‚

## **æ•°æ®éšå†™**

### æå–ä¿¡æ¯

#### é¢˜ç›®

éšå†™è§„åˆ™æç¤ºï¼š

1. å›¾ç‰‡çš„çº¢è‰²ï¼ˆRï¼‰é€šé“ä¸­éšè—äº†æ¨¡å‹è¾“å…¥ç‰¹å¾ï¼›
2. å–å›¾ç‰‡å·¦ä¸Šè§’å‰20ä¸ªåƒç´ çš„Rå€¼ï¼Œè®¡ç®— Rå€¼ mod 10 å¾—åˆ°20ç»´ç‰¹å¾ï¼›
3. 20ç»´ç‰¹å¾è¾“å…¥multimodal_model.pthæ¨¡å‹åï¼Œè¾“å‡ºçš„æ•°å€¼å–æ•´å³ä¸ºflagçš„ASCIIç ï¼›
4. ASCIIç è½¬æ¢ä¸ºå­—ç¬¦å³å¯å¾—åˆ°å®Œæ•´flagã€‚

æ¨¡å‹æç¤ºï¼š

- æ¨¡å‹ä¸ºè½»é‡å…¨è¿æ¥ç¥ç»ç½‘ç»œï¼ˆMLPï¼‰ï¼Œä»…å«3å±‚çº¿æ€§å±‚+ReLUæ¿€æ´»ã€‚

#### è§£ç­”

å…ˆæŸ¥çœ‹æ¨¡å‹ç»“æ„

```python
import torch

# Load the model state dictionary
model_path = "multimodal_model.pth"
try:
    # weights_only=False is needed for older pytorch versions or specific save formats, 
    # though strictly for weights it might not be needed, keeping it safe as per user's solve.py
    state_dict = torch.load(model_path, map_location='cpu') 
    
    print(f"Content of {model_path}:")
    for key, value in state_dict.items():
        if isinstance(value, torch.Tensor):
            print(f"{key}: {value.shape}")
        else:
            print(f"{key}: {type(value)}")

except Exception as e:
    print(f"Error loading file: {e}")

```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101192846.png)

ç¼–å†™pyè„šæœ¬å–æ•°

```python
import torch
import torch.nn as nn
from PIL import Image
import numpy as np

# å®šä¹‰å®Œå…¨ç›¸åŒçš„MLPæ¨¡å‹ç»“æ„ï¼ˆæ ¹æ®å®é™…æƒé‡ï¼š20->64->32->27ï¼‰
class MultimodalModel(nn.Module):
    def __init__(self):
        super(MultimodalModel, self).__init__()
        self.fc1 = nn.Linear(20, 64)
        self.relu1 = nn.ReLU()
        self.fc2 = nn.Linear(64, 32)
        self.relu2 = nn.ReLU()
        self.fc3 = nn.Linear(32, 27)
    
    def forward(self, x):
        x = self.fc1(x)
        x = self.relu1(x)
        x = self.fc2(x)
        x = self.relu2(x)
        x = self.fc3(x)
        return x

# 1. åŠ è½½å›¾ç‰‡å¹¶æå–Ré€šé“
image_path = r"c:\Users\33113\Desktop\æ•°ä¿¡æ¯\æ•°æ®éšå†™\secret_image.png"
img = Image.open(image_path)
img_array = np.array(img)

# è·å–Ré€šé“
r_channel = img_array[:, :, 0]  # Ré€šé“

# éšå†™ä¿¡æ¯åœ¨ç¬¬ä¸€åˆ—ï¼å–å‰20è¡Œçš„ç¬¬ä¸€åˆ—åƒç´ 
r_values = r_channel[:20, 0]
print("å·¦ä¸Šè§’å‰20è¡Œç¬¬ä¸€åˆ—çš„Rå€¼:", r_values)

# 2. è®¡ç®— Rå€¼ mod 10 å¾—åˆ°20ç»´ç‰¹å¾
features = r_values % 10
print("ç‰¹å¾ (R mod 10):", features)

# 3. åŠ è½½æ¨¡å‹
model_path = r"c:\Users\33113\Desktop\æ•°ä¿¡æ¯\æ•°æ®éšå†™\multimodal_model.pth"
model = MultimodalModel()
state_dict = torch.load(model_path, map_location='cpu', weights_only=False)
model.load_state_dict(state_dict)
model.eval()

# 4. å°†ç‰¹å¾è¾“å…¥æ¨¡å‹
input_tensor = torch.tensor(features, dtype=torch.float32).unsqueeze(0)
with torch.no_grad():
    output = model(input_tensor)

# 5. è¾“å‡ºå–æ•´å¾—åˆ°ASCIIç 
ascii_codes = output.squeeze().numpy().round().astype(int)
print("ASCIIç :", ascii_codes)

# 6. è½¬æ¢ä¸ºå­—ç¬¦
flag = ''.join([chr(code) for code in ascii_codes if 32 <= code <= 126])
print("Flag:", flag)

```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101192929.png)

## æµé‡æ•°æ®åˆ†æ

æŸå…¬å¸è¿ç»´å›¢é˜Ÿåœ¨æ—¥å¸¸å®‰å…¨å·¡æ£€è¿‡ç¨‹ä¸­å‘ç°ç³»ç»Ÿå­˜åœ¨å¼‚å¸¸è®¿é—®å’Œæ½œåœ¨å…¥ä¾µè¿¹è±¡ã€‚ç»åˆæ­¥æŠ€æœ¯ç ”åˆ¤ï¼Œé—®é¢˜å¯èƒ½ä¸å…¬å¸ç”¨äºå…³é”®æœåŠ¡å™¨ç›¸å…³ã€‚è¯¥æœåŠ¡å™¨è¢«ç¡®è®¤å­˜åœ¨ä¸€å®šå®‰å…¨é£é™©ï¼Œä½†ç›®å‰å°šæ— æ³•ç¡®å®šæ”»å‡»è€…æ˜¯å¦å·²æˆåŠŸè·å–å…¶ä¸­çš„è¯ä¹¦ä¿¡æ¯ã€‚ä¸ºè¿›ä¸€æ­¥æ’æŸ¥ä¸åˆ†ææ½œåœ¨çš„æ•°æ®æ³„æ¼æƒ…å†µï¼Œè¿ç»´å›¢é˜Ÿå·²å¯¼å‡ºè¯¥æœåŠ¡å™¨çš„æ‰€æœ‰ç½‘ç»œæµé‡æ–‡ä»¶ï¼Œè¯·æ ¹æ®æµé‡åŒ…æ–‡ä»¶åˆ†æå¹¶å›ç­”ä»¥ä¸‹çš„é—®é¢˜ã€‚

### è¯ä¹¦åˆæˆ

#### é¢˜ç›®

è¯·æ ¹æ®é¢˜ç›®æä¾›çš„è¯ä¹¦å…³é”®å‚æ•°ï¼Œåˆæˆç§é’¥è§£å¯†è¯ä¹¦ã€‚è¯·é€‰æ‰‹æ‰¾åˆ°idä¸º285çš„å‚æ•°åˆæˆçš„è¯ä¹¦(å‚è€ƒé™„ä»¶params.csv)ï¼Œå¯ä»¥è§£å¯†å“ªä¸ªæµé‡åŒ…(å‚è€ƒé™„ä»¶:pcap.zip)ã€‚å¹¶å°†å…¶æµé‡åŒ…åç§°ä½œä¸ºç­”æ¡ˆæäº¤ã€‚  
ã€ç­”æ¡ˆæ ‡å‡†ã€‘  
è‹¥idä¸º285çš„å‚æ•°åˆæˆè¯ä¹¦ï¼Œå¯ä»¥è§£å¯†"UT5NHVWo2Z.pcap"ï¼Œåˆ™ç­”æ¡ˆæäº¤ä¸ºUT5NHVWo2Z.pcap

#### è§£ç­”

æŸ¥çœ‹ä¸€ä¸ªæµé‡åŒ…å†…å®¹ï¼Œå‘ç°æ˜¯å…ˆåšäº†TLSå¯†é’¥äº¤æ¢ï¼Œç„¶åç”¨åŠ å¯†å½¢å¼ä¼ æ•°æ®

æŸ¥çœ‹params.csvæ–‡ä»¶ï¼Œå‘ç°æ˜¯rsaçš„eã€pã€qå€¼

å·²çŸ¥åœ¨TLSå¯†é’¥äº¤æ¢çš„æ—¶å€™ï¼Œä¼šä¼ é€’rsaæ¨¡æ•°nçš„å€¼

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101203927.png)

å› æ­¤å¯ä»¥é€šè¿‡nï¼Œæ‰¾åˆ°idä¸º285çš„å‚æ•°å¯ä»¥è§£å¯†å“ªä¸ªæµé‡åŒ…ã€‚

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import glob
from scapy.all import rdpcap, Raw
import warnings
from Crypto.Util.number import *
warnings.filterwarnings("ignore")

# è·¯å¾„é…ç½®
pcap_dir = r"c:\Users\33113\Desktop\æ•°ä¿¡æ¯\æ•°æ®æº¯æº\pcap"

# RSAå‚æ•° (id=285)
e = 65537
p = 177264302295959185550899884811457697789837321132319354039496340545988969470422347313577084568610012957139649359576035974322283705879187577664768699213211347033624840318251940972496063336844685896882713624561971974788692556498019960846465311267474369690812099681875735569564330504277517754796899917257323134723
q = 143990163909936129648804807321551478733567016733642335522156625973321506509458427490929508866189002322826874210961910641865602374675333206288577734876005828016379170951078934469472423840724164310343028554942665656763806178050620857070820746559094989518930589089970082522430002916286799917078785172333647028571

# è®¡ç®—n
n = p * q
print(f"n = {n}\n")

# è·å–æ‰€æœ‰pcapæ–‡ä»¶
pcap_files = glob.glob(os.path.join(pcap_dir, "*.pcap"))
print(f"æ‰¾åˆ° {len(pcap_files)} ä¸ªpcapæ–‡ä»¶")

matches = []

for i, pcap_file in enumerate(pcap_files):
    pcap_name = os.path.basename(pcap_file)
    try:
        # è¯»å–pcapæ–‡ä»¶
        packets = rdpcap(pcap_file)
        # éå†æ‰€æœ‰æ•°æ®åŒ…
        for pkt in packets:
            # æ£€æŸ¥æ˜¯å¦æœ‰Rawå±‚,å³è½½è·æ•°æ®
            if pkt.haslayer(Raw):
                # è·å–è½½è·æ•°æ®
                raw_data = bytes(pkt[Raw])
                # æ£€æŸ¥æ¨¡æ•°næ˜¯å¦åœ¨è½½è·æ•°æ®ä¸­
                n_bytes = long_to_bytes(n)
                if n_bytes in raw_data:
                    print(f"[åŒ¹é…!] {pcap_name}: æ‰¾åˆ°åŒ¹é…çš„æ¨¡æ•°")
                    matches.append(pcap_name)
                    break
    except Exception as e:
        pass
    
    if (i + 1) % 100 == 0:
        print(f"å·²å¤„ç† {i+1}/{len(pcap_files)} ä¸ªæ–‡ä»¶...")

print(f"\n=== åŒ¹é…çš„æ–‡ä»¶ ===")
for m in matches:
    print(m)

```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101204055.png)

### è¯ä¹¦è§£å¯†

#### é¢˜ç›®

è¯·æ ¹æ®ä¸Šé¢é¢˜ç›®å¯¹æ¯ä¸ªæµé‡åŒ…è¿›è¡Œè§£å¯†ï¼Œå¹¶å¾—åˆ°æ˜æ–‡ã€‚è¯·é€‰æ‰‹æ‰¾åˆ°"ç‹æ¢…"çš„æ‰‹æœºå·ï¼Œå¹¶è¿›è¡Œç­”æ¡ˆæäº¤ã€‚

ã€ç­”æ¡ˆæ ‡å‡†ã€‘è‹¥æ‰¾åˆ°"ç‹æ¢…"çš„æ‰‹æœºå·ä¸º15306364252ï¼Œåˆ™ç­”æ¡ˆæäº¤ä¸º15306364252

#### è§£ç­”

```python
"""
HTTPS æµé‡è§£å¯†è„šæœ¬ï¼ˆåŸºäºå·²çŸ¥ RSA ç§é’¥å‚æ•° e/p/qï¼‰

ã€åŸç†è¯´æ˜ã€‘
TLS/HTTPS æ¡æ‰‹ä¸­ï¼Œå®¢æˆ·ç«¯ç”Ÿæˆ48å­—èŠ‚é¢„ä¸»å¯†é’¥(Pre-Master Secret)ï¼Œç”¨æœåŠ¡å™¨RSAå…¬é’¥åŠ å¯†åå‘é€ã€‚
å·²çŸ¥RSAå‚æ•°(e,p,q)å¯ä»¥ï¼š
  1. è®¡ç®—ç§é’¥ d = e^(-1) mod Ï†(n)
  2. è§£å¯†é¢„ä¸»å¯†é’¥
  3. æ´¾ç”Ÿä¼šè¯å¯†é’¥å¹¶è§£å¯†åº”ç”¨æ•°æ®

ã€TLS 1.2 å¯†é’¥æ´¾ç”Ÿã€‘
  Pre-Master Secret â†’ PRF("master secret") â†’ Master Secret â†’ PRF("key expansion") â†’ Key Block
"""

import os
import re
import csv
import glob
import hmac
import struct
import hashlib
import warnings
from Crypto.Util.number import inverse, long_to_bytes, bytes_to_long
from Crypto.Cipher import AES
from scapy.all import rdpcap, Raw

warnings.filterwarnings("ignore")

# ========================= é…ç½® =========================
PCAP_DIR = r"C:\Users\33113\Desktop\æ•°ä¿¡æ¯\æ•°æ®æº¯æº\pcap"
PARAMS_FILE = r"C:\Users\33113\Desktop\æ•°ä¿¡æ¯\æ•°æ®æº¯æº\params.csv"


# ========================= TLS PRF =========================
def prf_sha256(secret, label, seed, length):
    """TLS 1.2 PRF (P_SHA256): è¿­ä»£HMACç”ŸæˆæŒ‡å®šé•¿åº¦çš„å¯†é’¥ææ–™"""
    result, a = b'', hmac.new(secret, label + seed, hashlib.sha256).digest()
    while len(result) < length:
        result += hmac.new(secret, a + label + seed, hashlib.sha256).digest()
        a = hmac.new(secret, a, hashlib.sha256).digest()
    return result[:length]


# ========================= RSAå‚æ•°åŠ è½½ =========================
def load_rsa_params(params_file):
    """åŠ è½½RSAå‚æ•°ï¼Œé¢„è®¡ç®—ç§é’¥dï¼Œè¿”å› (paramså­—å…¸, n_bytesæ˜ å°„)"""
    params, n_bytes_map = {}, {}
    with open(params_file, 'r') as f:
        for row in csv.DictReader(f):
            id_, e, p, q = int(row['id']), int(row['e']), int(row['p']), int(row['q'])
            n = p * q
            d = inverse(e, (p - 1) * (q - 1))
            params[id_] = {'n': n, 'd': d}
            n_bytes_map[long_to_bytes(n)] = id_
    return params, n_bytes_map


# ========================= TLSè§£æ =========================
def parse_tls_records(data):
    """
    è§£æTLSè®°å½•å±‚
    æ ¼å¼: ContentType(1) + Version(2) + Length(2) + Payload
    ContentType: 22=æ¡æ‰‹, 23=åº”ç”¨æ•°æ®
    """
    records, offset = [], 0
    while offset < len(data) - 5:
        ctype, length = data[offset], struct.unpack('>H', data[offset+3:offset+5])[0]
        if offset + 5 + length > len(data):
            break
        records.append({'type': ctype, 'payload': data[offset+5:offset+5+length]})
        offset += 5 + length
    return records


def parse_handshakes(payload):
    """
    è§£ææ¡æ‰‹æ¶ˆæ¯
    æ ¼å¼: Type(1) + Length(3) + Data
    Type: 1=ClientHello, 2=ServerHello, 16=ClientKeyExchange
    """
    messages, offset = [], 0
    while offset < len(payload) - 4:
        hs_type = payload[offset]
        length = struct.unpack('>I', b'\x00' + payload[offset+1:offset+4])[0]
        messages.append({'type': hs_type, 'data': payload[offset+4:offset+4+length]})
        offset += 4 + length
    return messages


def extract_tls_data(packets):
    """ä»æ•°æ®åŒ…ä¸­æå–TLSæ¡æ‰‹æ•°æ®å’Œåº”ç”¨æ•°æ®"""
    client_random = server_random = encrypted_pms = cipher_suite = None
    app_data_list = []
    
    for pkt in packets:
        if not pkt.haslayer(Raw):
            continue
        for record in parse_tls_records(bytes(pkt[Raw])):
            if record['type'] == 22:  # æ¡æ‰‹
                for hs in parse_handshakes(record['payload']):
                    data = hs['data']
                    if hs['type'] == 1 and len(data) >= 34:  # ClientHello
                        client_random = data[2:34]
                    elif hs['type'] == 2 and len(data) >= 34:  # ServerHello
                        server_random = data[2:34]
                        if len(data) >= 37:
                            sid_len = data[34]
                            if len(data) >= 37 + sid_len:
                                cipher_suite = struct.unpack('>H', data[35+sid_len:37+sid_len])[0]
                    elif hs['type'] == 16 and len(data) >= 2:  # ClientKeyExchange
                        pms_len = struct.unpack('>H', data[0:2])[0]
                        if len(data) >= 2 + pms_len:
                            encrypted_pms = data[2:2+pms_len]
            elif record['type'] == 23:  # åº”ç”¨æ•°æ®
                app_data_list.append(record['payload'])
    
    return client_random, server_random, encrypted_pms, cipher_suite, app_data_list


# ========================= RSAè§£å¯† =========================
def rsa_decrypt_pms(encrypted_pms, n, d):
    """RSAè§£å¯†é¢„ä¸»å¯†é’¥ï¼Œå»é™¤PKCS#1 v1.5å¡«å…… (00 02 [padding] 00 [data])"""
    m = pow(bytes_to_long(encrypted_pms), d, n)
    decrypted = long_to_bytes(m)
    
    # å»é™¤PKCS#1 v1.5å¡«å……
    if len(decrypted) > 11 and decrypted[:2] == b'\x00\x02':
        sep = decrypted.find(b'\x00', 2)
        pms = decrypted[sep+1:] if sep >= 10 else decrypted[-48:]
    else:
        pms = decrypted[-48:] if len(decrypted) >= 48 else decrypted
    
    return pms if len(pms) == 48 else None


# ========================= ä¼šè¯å¯†é’¥æ´¾ç”Ÿ =========================
def derive_keys(pms, client_random, server_random, is_gcm):
    """æ´¾ç”Ÿä¸»å¯†é’¥å’Œä¼šè¯å¯†é’¥"""
    master = prf_sha256(pms, b"master secret", client_random + server_random, 48)
    
    if is_gcm:
        # AES-GCM: key(16) + key(16) + iv(4) + iv(4) = 40 bytes
        kb = prf_sha256(master, b"key expansion", server_random + client_random, 40)
        return kb[0:16], kb[16:32], kb[32:36], kb[36:40]
    else:
        # AES-CBC: mac(20) + mac(20) + key(16) + key(16) = 72 bytes (TLS 1.1+ ä½¿ç”¨æ˜¾å¼IV)
        kb = prf_sha256(master, b"key expansion", server_random + client_random, 72)
        return kb[40:56], kb[56:72], None, None


# ========================= åº”ç”¨æ•°æ®è§£å¯† =========================
def decrypt_app_data(app_data_list, client_key, server_key, client_iv, server_iv, is_gcm):
    """è§£å¯†åº”ç”¨å±‚æ•°æ®"""
    results = []
    
    for data in app_data_list:
        if len(data) < 16:
            continue
        
        if is_gcm:
            from cryptography.hazmat.primitives.ciphers.aead import AESGCM
            explicit_nonce, ciphertext = data[:8], data[8:]
            
            for key, iv in [(client_key, client_iv), (server_key, server_iv)]:
                nonce = iv + explicit_nonce
                for seq in range(20):  # å°è¯•ä¸åŒåºåˆ—å·
                    aad = struct.pack('>Q', seq) + b'\x17\x03\x03' + struct.pack('>H', len(ciphertext) - 16)
                    try:
                        results.append(AESGCM(key).decrypt(nonce, ciphertext, aad).decode('utf-8', errors='ignore'))
                        break
                    except:
                        pass
                else:
                    continue
                break
        else:
            # AES-CBC (TLS 1.1+ æ˜¾å¼IV)
            iv, ciphertext = data[:16], data[16:]
            for key in [client_key, server_key]:
                try:
                    decrypted = AES.new(key, AES.MODE_CBC, iv).decrypt(ciphertext)
                    pad = decrypted[-1]
                    if 0 < pad <= 16 and all(b == pad for b in decrypted[-pad:]):
                        plaintext = decrypted[:-pad-20]  # å»é™¤å¡«å……å’ŒMAC(SHA1=20)
                        results.append(plaintext.decode('utf-8', errors='ignore'))
                        break
                except:
                    pass
    
    return results


# ========================= æ ¸å¿ƒè§£å¯†å‡½æ•° =========================
def decrypt_pcap(pcap_file, params, n_bytes_map):
    """è§£å¯†å•ä¸ªpcapæ–‡ä»¶"""
    packets = rdpcap(pcap_file)
    
    # æ”¶é›†åŸå§‹æ•°æ®å¹¶åŒ¹é…RSAå‚æ•°
    all_raw = b''.join(bytes(pkt[Raw]) for pkt in packets if pkt.haslayer(Raw))
    if not all_raw:
        return None
    
    matched_id = next((id_ for n_bytes, id_ in n_bytes_map.items() if n_bytes in all_raw), None)
    if not matched_id:
        return None
    
    n, d = params[matched_id]['n'], params[matched_id]['d']
    
    # æå–TLSæ•°æ®
    client_random, server_random, encrypted_pms, cipher_suite, app_data_list = extract_tls_data(packets)
    if not all([client_random, server_random, encrypted_pms, app_data_list]):
        return None
    
    # è§£å¯†é¢„ä¸»å¯†é’¥
    pms = rsa_decrypt_pms(encrypted_pms, n, d)
    if not pms:
        return None
    
    # æ´¾ç”Ÿå¯†é’¥å¹¶è§£å¯†
    is_gcm = cipher_suite in [0x009C, 0x009D]
    client_key, server_key, client_iv, server_iv = derive_keys(pms, client_random, server_random, is_gcm)
    
    return decrypt_app_data(app_data_list, client_key, server_key, client_iv, server_iv, is_gcm)


# ========================= ä¸»ç¨‹åº =========================
if __name__ == "__main__":
    print("ğŸ“– è¯»å–RSAå‚æ•°...")
    params, n_bytes_map = load_rsa_params(PARAMS_FILE)
    print(f"âœ… å…±è¯»å– {len(params)} ç»„RSAå‚æ•°")
    
    pcap_files = glob.glob(os.path.join(PCAP_DIR, "*.pcap"))
    print(f"ğŸ“ æ‰¾åˆ° {len(pcap_files)} ä¸ªpcapæ–‡ä»¶")
    
    all_results, success = [], 0
    
    for i, pcap_file in enumerate(pcap_files):
        name = os.path.basename(pcap_file)
        try:
            texts = decrypt_pcap(pcap_file, params, n_bytes_map)
            if texts:
                success += 1
                for text in texts:
                    all_results.append((name, text))
                    if 'ç‹æ¢…' in text or '\\u738b\\u6885' in text:
                        print(f"\nğŸ¯ [æ‰¾åˆ°ç›®æ ‡!] {name}\n{text[:500]}")
                        match = re.search(r'"phone":\s*"(\d+)"', text)
                        if match:
                            print(f"ğŸ“± æ‰‹æœºå·: {match.group(1)}")
        except:
            pass
        
        if (i + 1) % 50 == 0:
            print(f"â³ å·²å¤„ç† {i+1}/{len(pcap_files)}ï¼ŒæˆåŠŸ {success} ä¸ª...")
    
    print(f"\n{'='*60}")
    print(f"âœ… å®Œæˆï¼å¤„ç† {len(pcap_files)} æ–‡ä»¶ï¼ŒæˆåŠŸ {success} ä¸ªï¼Œå…± {len(all_results)} æ¡è®°å½•")
    
    output = os.path.join(os.path.dirname(PCAP_DIR), "all_decrypted_new.txt")
    with open(output, 'w', encoding='utf-8') as f:
        for name, text in all_results:
            f.write(f"=== {name} ===\n{text}\n\n")
    print(f"ğŸ“„ å·²ä¿å­˜åˆ° {output}")

```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101214352.png)

### æ•°æ®æ ¸éªŒ

#### é¢˜ç›®

ä¸ºäº†å®‰å…¨å¯é ï¼Œè¯¥ç³»ç»Ÿåœ¨è¯·æ±‚åŒ…è®¾ç½®äº†Authorizationå¤´éƒ¨å­—æ®µã€‚è¯¥å­—æ®µæ˜¯ä½¿ç”¨JWTè¿›è¡ŒåŠ å¯†çš„ï¼Œæ¯ä¸ªäººçš„å¯†é’¥ä¸ºäº†å®‰å…¨è€ƒè™‘è®¾ç½®æˆè‡ªå·±å§“åçš„æ‹¼éŸ³ã€‚è¯·é€‰æ‰‹è§£å¯†JWTèº«ä»½è®¤è¯æ ¸å¯¹ä¿¡æ¯æ˜¯å¦ä¸è¯·æ±‚ä½“ä¸­çš„å†…å®¹æ˜¯å¦ä¸€è‡´ã€‚è‹¥éä¸€è‡´ï¼Œè¯¥ç”¨æˆ·å¯èƒ½åœ¨è¿›è¡Œè¶Šæƒè®¿é—®ã€‚è¯·é€‰æ‰‹ç»Ÿè®¡å‡ºæœ‰å¤šå°‘ä¸ªè´¦å·è¿›è¡Œè¶Šæƒã€‚  
ã€ç­”æ¡ˆæ ‡å‡†ã€‘  
è‹¥æœ‰101ä¸ªè´¦å·è¿›è¡Œè¶Šæƒï¼Œåˆ™ç­”æ¡ˆæäº¤ä¸º101

#### è§£ç­”

```python
"""
JWT è¶Šæƒè®¿é—®æ£€æµ‹è„šæœ¬

ã€åŠŸèƒ½è¯´æ˜ã€‘
æ£€æµ‹HTTPSè¯·æ±‚ä¸­æ˜¯å¦å­˜åœ¨è¶Šæƒè®¿é—®ï¼š
  - è§£æè§£å¯†åçš„HTTPè¯·æ±‚
  - æ¯”è¾ƒJWTä»¤ç‰Œä¸­çš„ç”¨æˆ·ä¿¡æ¯ä¸è¯·æ±‚ä½“ä¸­çš„ç”¨æˆ·ä¿¡æ¯
  - å¦‚æœä¸ä¸€è‡´ï¼Œè¯´æ˜ç”¨æˆ·Aä½¿ç”¨è‡ªå·±çš„JWTè®¿é—®ç”¨æˆ·Bçš„æ•°æ®ï¼ˆè¶Šæƒï¼‰

ã€JWTç»“æ„ã€‘
JWTç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼Œç”¨.åˆ†éš”ï¼šHeader.Payload.Signature
  - Header: {"alg": "HS256", "typ": "JWT"}
  - Payload: {"username": "xxx", "phone": "xxx"} (ç”¨æˆ·ä¿¡æ¯)
  - Signature: HMAC-SHA256ç­¾å

ã€è¶Šæƒåˆ¤å®šã€‘
è‹¥ JWT.payload.username â‰  Body.username æˆ– JWT.payload.phone â‰  Body.phone
åˆ™åˆ¤å®šä¸ºè¶Šæƒè®¿é—®ï¼ˆç”¨æˆ·è¯•å›¾ä¿®æ”¹ä»–äººæ•°æ®ï¼‰
"""

import re
import json
import base64
import hashlib


def base64url_decode(data):
    """Base64URLè§£ç ï¼ˆè‡ªåŠ¨è¡¥é½paddingï¼‰"""
    padding = 4 - len(data) % 4
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)


def decode_jwt_payload(token):
    """
    è§£ç JWTçš„Payloadéƒ¨åˆ†ï¼ˆä¸éªŒè¯ç­¾åï¼‰
    
    JWTæ ¼å¼: header.payload.signature
    Payloadæ˜¯Base64URLç¼–ç çš„JSON
    """
    try:
        parts = token.split('.')
        if len(parts) != 3:
            return None
        return json.loads(base64url_decode(parts[1]).decode('utf-8'))
    except:
        return None


def parse_decrypted_file(content):
    """
    è§£æè§£å¯†æ–‡ä»¶ï¼Œæå–æ¯ä¸ªpcapå¯¹åº”çš„è¯·æ±‚å†…å®¹
    
    æ–‡ä»¶æ ¼å¼:
        === xxx.pcap ===
        HTTPè¯·æ±‚å†…å®¹...
        
        === yyy.pcap ===
        HTTPè¯·æ±‚å†…å®¹...
    
    è¿”å›: [(pcap_name, request_content), ...]
    """
    pattern = r'=== ([^=]+\.pcap) ==='
    parts = re.split(pattern, content)
    
    # partsç»“æ„: ['', pcap1, content1, pcap2, content2, ...]
    return [(parts[i].strip(), parts[i + 1]) 
            for i in range(1, len(parts), 2) 
            if i + 1 < len(parts)]


def extract_jwt_and_body(request):
    """
    ä»HTTPè¯·æ±‚ä¸­æå–JWTä»¤ç‰Œå’ŒJSONè¯·æ±‚ä½“
    
    JWTä½ç½®: Authorization: Bearer <token>
    è¯·æ±‚ä½“: {"username": "xxx", "phone": "xxx"}
    """
    # æå–JWT
    jwt_match = re.search(r'Authorization: Bearer ([^\s\r\n]+)', request)
    jwt_token = jwt_match.group(1) if jwt_match else None
    
    # æå–JSONè¯·æ±‚ä½“
    body_match = re.search(r'\{[^{}]+\}', request)
    try:
        body = json.loads(body_match.group(0)) if body_match else None
    except:
        body = None
    
    return jwt_token, body


def check_authorization(jwt_token, body):
    """
    æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¶Šæƒè®¿é—®
    
    æ¯”è¾ƒJWTä¸­çš„ç”¨æˆ·ä¿¡æ¯ä¸è¯·æ±‚ä½“ä¸­çš„ç”¨æˆ·ä¿¡æ¯
    è¿”å›: (is_unauthorized, jwt_info, body_info)
    """
    payload = decode_jwt_payload(jwt_token)
    if not payload:
        return None, None, None
    
    jwt_info = (payload.get('username', ''), payload.get('phone', ''))
    body_info = (body.get('username', ''), body.get('phone', ''))
    
    # è¶Šæƒåˆ¤å®šï¼šJWTä¸­çš„ç”¨æˆ·ä¿¡æ¯ä¸è¯·æ±‚ä½“ä¸ä¸€è‡´
    is_unauthorized = jwt_info != body_info
    
    return is_unauthorized, jwt_info, body_info


def main():
    # è¯»å–è§£å¯†åçš„è¯·æ±‚æ•°æ®
    with open('all_decrypted_new.txt', 'r', encoding='utf-8') as f:
        content = f.read()
    
    requests = parse_decrypted_file(content)
    print(f"ğŸ“‚ å…±è§£æ {len(requests)} ä¸ªè¯·æ±‚")
    
    unauthorized_list = []
    
    for pcap_name, request_content in requests:
        jwt_token, body = extract_jwt_and_body(request_content)
        
        # è·³è¿‡æ— æ³•è§£æçš„è¯·æ±‚
        if not jwt_token or not body:
            continue
        
        is_unauthorized, jwt_info, body_info = check_authorization(jwt_token, body)
        
        if is_unauthorized is None:
            print(f"[ERROR] {pcap_name}: JWTè§£ç å¤±è´¥")
            continue
        
        if is_unauthorized:
            unauthorized_list.append({
                'pcap': pcap_name,
                'jwt': {'username': jwt_info[0], 'phone': jwt_info[1]},
                'body': {'username': body_info[0], 'phone': body_info[1]}
            })
            print(f"ğŸš¨ [è¶Šæƒ] {pcap_name}")
            print(f"   JWT:  username={jwt_info[0]}, phone={jwt_info[1]}")
            print(f"   Body: username={body_info[0]}, phone={body_info[1]}")
    
    # è¾“å‡ºç»Ÿè®¡ç»“æœ
    count = len(unauthorized_list)
    print(f"\n{'='*50}")
    print(f"âœ… æ£€æµ‹å®Œæˆï¼å‘ç° {count} ä¸ªè¶Šæƒè®¿é—®")
    print(f"ğŸ”‘ ç­”æ¡ˆMD5: {hashlib.md5(str(count).encode()).hexdigest()}")


if __name__ == '__main__':
    main()

```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101214433.png)

## æ–‡æ¡£å®‰å…¨äº‹ä»¶åˆ†æ

éšç€ç»´çœŸç§‘æŠ€(VerityTech)ä¸šåŠ¡è§„æ¨¡çš„ä¸æ–­æ‰©å¼ ï¼Œå…¬å¸ç§¯ç´¯äº†å¤§é‡å†…éƒ¨ PDF æ–‡æ¡£ï¼ŒåŒ…æ‹¬é‡è¦çš„ç ”å‘èµ„æ–™ã€ä¸šåŠ¡æŠ¥å‘Šã€å†…éƒ¨åˆ¶åº¦è¯´æ˜ç­‰ã€‚åœ¨é•¿æœŸçš„è¿ä½œè¿‡ç¨‹ä¸­ï¼Œç”±äºæ–‡æ¡£ç®¡ç†è§„èŒƒä¸å®Œå–„ã€ç¼ºä¹ç»Ÿä¸€çš„å®‰å…¨ç­–ç•¥ï¼Œå…¬å¸æ–‡æ¡£çš„å®‰å…¨é£é™©é€æ¸æ˜¾ç°ã€‚  
è¿‘æœŸï¼Œå…¬å¸æ–‡æ¡£æœåŠ¡å™¨é­é‡æœªçŸ¥å‹’ç´¢ç¨‹åºæ”»å‡»ã€‚éƒ¨åˆ† PDF æ–‡ä»¶è¢«åŠ å¯†æ— æ³•æ‰“å¼€ï¼Œç³»ç»Ÿä¸­è¿˜å‡ºç°å¯ç–‘é“¾æ¥çš„æ–‡æ¡£ï¼Œç–‘ä¼¼ä¸ºæ”»å‡»å…¥å£ã€‚åŒæ—¶ï¼Œå®‰å…¨å›¢é˜Ÿåœ¨å—æ„ŸæŸ“ç»ˆç«¯ä¸­æå–åˆ°äº†ä¸€ä»½å¯ç–‘çš„å¯æ‰§è¡Œç¨‹åº(exe æ–‡ä»¶)ï¼Œæ¨æµ‹ä¸ºå‹’ç´¢ç¨‹åºä¸»ä½“ã€‚  
ä¸ºäº†å®šä½å®‰å…¨æ¼æ´ã€æ¢å¤æ–‡æ¡£æ•°æ®ã€æŸ¥æ˜æ”»å‡»æ¥æºï¼Œå…¬å¸å¯åŠ¨äº†â€œæ–‡æ¡£å®‰å…¨äº‹ä»¶åˆ†æâ€:ä¸“é¡¹å·¥ä½œã€‚æœ¬é¢˜ç»™å‡ºæ”»å‡»æ ·æœ¬ã€åŠ å¯†æ–‡æ¡£åŠç–‘ä¼¼é’“é±¼ PDF æ–‡æ¡£ï¼Œè¯·ä½ ååŠ©å®‰å…¨å›¢é˜Ÿè¿›è¡Œå–è¯åˆ†æã€å¯†é’¥æ¢å¤ã€æ•°æ®è§£å¯†ä»¥åŠé’“é±¼é“¾æ¥è¯†åˆ«ã€‚

å…¬å¸åˆæ³•åŸŸåä¸º:veritytech.comä»¥åŠå…¶å­åŸŸ:  
*.veritytech.comå…¶ä½™åŸŸåå‡è§†ä¸ºå¯ç–‘é“¾æ¥ï¼Œéœ€é‡ç‚¹å®¡æŸ¥ã€‚

### å¯†é’¥å–è¯

#### é¢˜ç›®

å®‰å…¨å›¢é˜Ÿæå–åˆ°ç–‘ä¼¼å‹’ç´¢ç¨‹åº(exe æ–‡ä»¶)ï¼Œè¯¥ç¨‹åºé‡‡ç”¨"æ··åˆåŠ å¯†æœºåˆ¶"å¯¹ PDF æ–‡æ¡£è¿›è¡ŒåŠ å¯†ä½¿ç”¨

- RSA å…¬é’¥åŠ å¯† AES å¯†é’¥(ç”¨äºå®‰å…¨å­˜å‚¨/ä¼ è¾“ AES å¯†é’¥);
- ä½¿ç”¨åŸå§‹çš„ AES å¯†é’¥(æ˜æ–‡)ç›´æ¥åŠ å¯† PDF æ–‡æ¡£ã€‚

è‹¥è¦æ¢å¤æ–‡æ¡£ï¼Œå¿…é¡»ä»å‹’ç´¢ç¨‹åºä¸­è·å–æ”»å‡»è€…é—ç•™çš„ RSA ç§é’¥ã€‚

è¯·ä½ åˆ†æå‹’ç´¢ç¨‹åºï¼Œæ‰¾åˆ°ç§é’¥ï¼Œå¹¶å°†ç§é’¥ä¸­"----BEGIN PRIVATE KEY--â€¦â€¦"ä¹‹åçš„32ä¸ºå­—ç¬¦å½“åšç­”æ¡ˆæäº¤ã€‚

#### è§£ç­”

ç”¨è®°äº‹æœ¬æ‰“å¼€exeæ–‡ä»¶ï¼Œå‘ç°é‡Œé¢æœ‰pythonå…³é”®å­—ï¼Œåˆ¤æ–­ä¸ºpythonæ‰“åŒ…çš„exeæ–‡ä»¶

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101225207.png)

ä½¿ç”¨pyinstxtractor.pyè§£åŒ…ï¼Œæ‰¾åˆ°key

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101225315.png)

```python
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCt4TrETrlzU4NV
...
```

### æ•°æ®è§£å¯†

#### é¢˜ç›®

åœ¨æˆåŠŸè·å¾—æ”»å‡»è€…çš„ RSA ç§é’¥åï¼Œå¯è§£å¯† AES å¯†é’¥ï¼Œå¹¶è¿›ä¸€æ­¥è§£å¯†è¢«å‹’ç´¢çš„ PDF æ–‡ä»¶ã€‚è¯·ä½¿ç”¨æ­£ç¡®çš„ç§é’¥æ¢å¤æ–‡ä»¶å†…å®¹ã€‚  
è¯·è®¡ç®—"0999_å†…éƒ¨æ–‡æ¡£0999.pdf"è§£å¯†å,æ–‡ä»¶çš„ MD5 å€¼ï¼Œå¹¶æäº¤å…¶ 32 ä½å°å†™ MD5 ä½œä¸ºç­”æ¡ˆã€‚

#### è§£ç­”

ä½¿ç”¨pycdc.exeåç¼–è¯‘en.exe_extracted\encrypt_files.pycï¼ŒæŸ¥çœ‹ä½¿ç”¨çš„æ˜¯AESå“ªç§æ¨¡å¼

```python
# pycdc.exe encrypt_files.pyc > encrypt.py
def encrypt_file_aes_ecb(file_path, aes_key, output_path = (None,)):
    '''
    ä½¿ç”¨AES-256-ECBç®—æ³•åŠ å¯†æ–‡ä»¶
    
    Args:
        file_path: è¦åŠ å¯†çš„æ–‡ä»¶è·¯å¾„
        aes_key: AESå¯†é’¥ï¼ˆ32å­—èŠ‚ï¼‰
        output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœä¸ºNoneåˆ™æ·»åŠ .encåç¼€
        
    Returns:
        åŠ å¯†åçš„æ–‡ä»¶è·¯å¾„
    '''
    with open(file_path, 'rb') as f:
        plaintext = f.read()
        None(None, None, None)
```

ç¼–å†™è§£å¯†ä»£ç 

```python
"""
æ‰¹é‡æ–‡ä»¶è§£å¯†ç¨‹åº
ä½¿ç”¨RSAç§é’¥è§£å¯†AESå¯†é’¥ï¼Œç„¶åä½¿ç”¨AES-256-ECBç®—æ³•è§£å¯†æ–‡ä»¶
"""
import os
from pathlib import Path
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding, hashes
from cryptography.hazmat.primitives.asymmetric import padding as asym_padding
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend


def load_rsa_private_key(private_key_file):
    """
    ä»æ–‡ä»¶åŠ è½½RSAç§é’¥
    """
    with open(private_key_file, 'rb') as f:
        private_key = serialization.load_pem_private_key(
            f.read(),
            password=None,
            backend=default_backend()
        )
    return private_key


def decrypt_aes_key_with_rsa(encrypted_key_file, private_key):
    """
    ä½¿ç”¨RSAç§é’¥è§£å¯†AESå¯†é’¥
    """
    with open(encrypted_key_file, 'rb') as f:
        encrypted_key = f.read()
    
    # ä½¿ç”¨OAEP paddingè§£å¯† (ä¸åŠ å¯†æ—¶ä½¿ç”¨çš„ç›¸åŒ)
    aes_key = private_key.decrypt(
        encrypted_key,
        asym_padding.OAEP(
            mgf=asym_padding.MGF1(algorithm=hashes.SHA256()),
            algorithm=hashes.SHA256(),
            label=None
        )
    )
    return aes_key


def decrypt_file_aes_ecb(file_path, aes_key, output_path=None):
    """
    ä½¿ç”¨AES-256-ECBç®—æ³•è§£å¯†æ–‡ä»¶
    """
    with open(file_path, 'rb') as f:
        ciphertext = f.read()
    
    # åˆ›å»ºAES-ECBè§£å¯†å™¨
    cipher = Cipher(algorithms.AES(aes_key), modes.ECB(), backend=default_backend())
    decryptor = cipher.decryptor()
    
    # è§£å¯†æ•°æ®
    padded_plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    
    # ç§»é™¤PKCS7å¡«å……
    unpadder = padding.PKCS7(128).unpadder()
    plaintext = unpadder.update(padded_plaintext) + unpadder.finalize()
    
    # ç¡®å®šè¾“å‡ºè·¯å¾„
    if output_path is None:
        # ç§»é™¤.encåç¼€
        if str(file_path).endswith('.enc'):
            output_path = str(file_path)[:-4]
        else:
            output_path = str(file_path) + '.dec'
    
    with open(output_path, 'wb') as f:
        f.write(plaintext)
    
    return output_path


def batch_decrypt_files(directory, private_key_file, encrypted_key_file):
    """
    æ‰¹é‡è§£å¯†æŒ‡å®šç›®å½•ä¸‹çš„.encæ–‡ä»¶
    """
    print(f"æ­£åœ¨åŠ è½½RSAç§é’¥: {private_key_file}")
    private_key = load_rsa_private_key(private_key_file)
    
    print(f"æ­£åœ¨è§£å¯†AESå¯†é’¥: {encrypted_key_file}")
    aes_key = decrypt_aes_key_with_rsa(encrypted_key_file, private_key)
    print(f"AESå¯†é’¥å·²è§£å¯†ï¼Œé•¿åº¦: {len(aes_key)} å­—èŠ‚")
    
    # ä¿å­˜è§£å¯†åçš„AESå¯†é’¥
    with open("decrypted_aes.key", 'wb') as f:
        f.write(aes_key)
    print("AESå¯†é’¥å·²ä¿å­˜åˆ° decrypted_aes.key")
    
    # æŸ¥æ‰¾æ‰€æœ‰.encæ–‡ä»¶
    directory_path = Path(directory)
    enc_files = list(directory_path.glob("**/*.enc"))
    
    if not enc_files:
        print("æœªæ‰¾åˆ°éœ€è¦è§£å¯†çš„.encæ–‡ä»¶")
        return
    
    print(f"\næ‰¾åˆ° {len(enc_files)} ä¸ªæ–‡ä»¶éœ€è¦è§£å¯†")
    print("-" * 50)
    
    decrypted_count = 0
    for enc_file in enc_files:
        try:
            output_path = decrypt_file_aes_ecb(enc_file, aes_key)
            print(f"å·²è§£å¯†: {enc_file.name} -> {Path(output_path).name}")
            decrypted_count += 1
        except Exception as e:
            print(f"è§£å¯†å¤±è´¥: {enc_file.name} - {e}")
    
    print("-" * 50)
    print(f"è§£å¯†å®Œæˆ! æˆåŠŸè§£å¯† {decrypted_count}/{len(enc_files)} ä¸ªæ–‡ä»¶")


if __name__ == "__main__":
    # è®¾ç½®è·¯å¾„
    base_dir = r"c:\Users\33113\Desktop\æ•°ä¿¡æ¯\enpdf"
    private_key_file = os.path.join(base_dir, "key", "pr.pem")
    encrypted_key_file = os.path.join(base_dir, "store.key")
    pdfs_directory = os.path.join(base_dir, "pdfs")
    
    batch_decrypt_files(pdfs_directory, private_key_file, encrypted_key_file)

```

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260101234131.png)

æäº¤è¯¥æ–‡æ¡£md5å€¼å³å¯

### é’“é±¼é“¾æ¥ğŸ’©ğŸ’©ğŸ’©

#### é¢˜ç›®

åœ¨äº‹ä»¶è°ƒæŸ¥ä¸­ï¼Œå®‰å…¨å›¢é˜Ÿç»Ÿè®¡å‡ºå…±è®¡ 999 ä»½ PDF æ–‡æ¡£ï¼Œå…¶ä¸­éƒ¨åˆ†æ–‡æ¡£åŒ…å«å†…éƒ¨å¤–é“¾ã€‚ä¸ºé¿å…å®‰å…¨é£é™©ï¼Œéœ€å¯¹æ‰€æœ‰æ–‡æ¡£è¿›è¡Œé“¾æ¥å®¡æŸ¥ã€‚  
PDF ä¸­çš„ URL å¯èƒ½ä»¥ä»¥ä¸‹å½¢å¼å‡ºç°:  
	1. æ–‡æœ¬ä¸­ç›´æ¥æ˜¾ç¤ºçš„ URL  
	2. éšè—åœ¨ PDF Annotation è¶…é“¾æ¥å†…çš„ URL(æ˜¾ç¤ºå†…å®¹ä¸çœŸå®è·³è½¬åœ°å€å¯èƒ½ä¸åŒ)  
	3. URL å‚æ•°ä¸­çš„è·³è½¬åœ°å€:æŸäº› URL å¯èƒ½åŒ…å« redirectã€nextã€ur1 ç­‰å‚æ•°ï¼Œå‚æ•°å€¼æŒ‡å‘å®é™…è·³è½¬çš„ç›®æ ‡åœ°å€(å³ä½¿ URL æœ¬èº«çš„ä¸»åŸŸåä¸ºåˆæ³•åŸŸåï¼Œå‚æ•°ä¸­çš„è·³è½¬åœ°å€ä¹Ÿéœ€è¦å•ç‹¬æ£€æŸ¥)

å…¬å¸åˆæ³•åŸŸåèŒƒå›´ä¸º:  
veritytech.com åŠå…¶æ‰€æœ‰å­åŸŸå(*.veritytech.com)

è¯·åˆ†æ 999ä»½PDFï¼Œæ‰¾å‡ºæ‰€æœ‰æŒ‡å‘é veritvtech,com åŸŸå çš„ URL(åŒ…æ‹¬æ–‡æœ¬æ˜¾ç¤ºã€Annotation è·³è½¬ URIä»¥åŠ URL å‚æ•°ä¸­çš„è·³è½¬åœ°å€)ï¼Œæå–å…¶å®Œæ•´URLï¼ŒæŒ‰å­—å…¸åºå‡åºæ’åºåï¼Œç”¨è‹±æ–‡åŠè§’é€—å·æ‹¼æ¥ï¼Œæœ€ç»ˆå¯¹æ‹¼æ¥å­—ç¬¦ä¸²è®¡ç®— 32 ä½å°å†™ MD5 ä½œä¸ºç­”æ¡ˆã€‚  
å¯¹äºåŒ…å«è·³è½¬å‚æ•°çš„ URL(å¦‚ https://mail.veritytech.com/auth?next=https://evi1.com)ï¼Œå¦‚æœ URLæœ¬èº«çš„ä¸»åŸŸåä¸ºåˆæ³•åŸŸåï¼Œåˆ™ä¸åº”æå–è¯¥å®Œæ•´ URL;ä½†éœ€è¦æå–å‚æ•°ä¸­çš„è·³è½¬åœ°å€(å¦‚ https://evi1.com)è¿›è¡Œåˆ¤æ–­ã€‚

è‹¥è¯†åˆ«å‡ºçš„é’“é±¼é“¾æ¥ä¸ºå¦‚ä¸‹3æ¡(å­—å…¸åºå‡åº)  
https://company.com/login  
https://veritytech.com.io/auth  
https://verify-veritytech.xyz/update  
åˆ™æ‹¼æ¥ä¸º:  
https://company.com/login,https://veritytech.com.io/auth,https://verify-veritytech.xyz/update  
å¯¹è¯¥å­—ç¬¦ä¸²è®¡ç®— MD5 å³ä¸ºæœ€ç»ˆæäº¤å€¼ï¼Œä¾‹å¦‚:  
7c57e0774ddf8f4b8539b255a8f6f506

ç¤ºä¾‹è¯´æ˜:  
å¦‚æœ PDF ä¸­å­˜åœ¨ URL https://mail.veritytech.com/auth?next=https://evi1.com/loginï¼Œç”±äºå®Œæ•´URLçš„ä¸»åŸŸåä¸º mail.veritytech.com(åˆæ³•)ä¸åº”æå–è¯¥å®Œæ•´ URL;ä½†éœ€è¦æå–å‚æ•°ä¸­çš„ https://evi1.com/login è¿›è¡Œåˆ¤æ–­ï¼Œè‹¥å…¶ä¸»åŸŸåä¸ºéveritytech.com åŸŸåï¼Œåˆ™åº”æå–è¯¥ URLã€‚  
å¦‚æœ PDF æ–‡æœ¬ä¸­ç›´æ¥æ˜¾ç¤º https://evil.com/loginï¼Œåˆ™ç›´æ¥æå–è¯¥ URLã€‚  
å¦‚æœ PDF Annotation ä¸­éšè—çš„è·³è½¬åœ°å€ä¸º https://evi1.com/loginï¼Œåˆ™æå–è¯¥ URLã€‚

#### è§£ç­”

æ¯”èµ›æ—¶é—´å†…æ²¡åšå‡ºæ¥ï¼Œä¸çŸ¥é“ä¸‹é¢è„šæœ¬å¯¹ä¸å¯¹

```python
"""
æœ€ç»ˆéªŒè¯è„šæœ¬ - å…¨é¢æ£€æŸ¥æ‰€æœ‰URL
"""

import os
import re
import hashlib
from urllib.parse import urlparse, parse_qs, unquote
import fitz  # PyMuPDF


def clean_url(url):
    """æ¸…ç†URLï¼Œç§»é™¤æœ«å°¾çš„éURLå­—ç¬¦"""
    url = re.sub(r'[\u4e00-\u9fffï¼Œã€‚ã€ï¼›ï¼šï¼ï¼Ÿã€ã€‘ï¼ˆï¼‰ã€Šã€‹""'']+.*$', '', url)
    while url and url[-1] in '.,;:!?)]\'"':
        url = url[:-1]
    return url


def is_valid_url(url):
    """æ£€æŸ¥URLæ˜¯å¦æœ‰æ•ˆï¼ˆæœ‰å®Œæ•´çš„åŸŸåï¼‰"""
    try:
        parsed = urlparse(url)
        netloc = parsed.netloc.lower()
        if ':' in netloc:
            host = netloc.split(':')[0]
        else:
            host = netloc
        
        if not host or '.' not in host:
            return False
        
        parts = host.split('.')
        if len(parts[-1]) < 2:
            return False
        
        incomplete_endings = [
            'veri', 'verit', 'verity', 'verityt', 'verityte', 'veritytec', 'veritytech',
            've', 'ver'
        ]
        if parts[-1] in incomplete_endings:
            return False
        
        if host.endswith('.veritytech') or host.endswith('.veritytec') or \
           host.endswith('.verityte') or host.endswith('.verityt') or \
           host.endswith('.verity') or host.endswith('.verit') or \
           host.endswith('.veri') or host.endswith('.ver') or host.endswith('.ve'):
            return False
        
        if host.endswith('.veritytech.co') and (not parsed.path or parsed.path == '/'):
            return False
        
        return True
    except:
        return False


def extract_domain(url):
    """æå–URLçš„ä¸»åŸŸå"""
    try:
        parsed = urlparse(url)
        return parsed.netloc.lower()
    except:
        return ""


def get_host(domain):
    """ä»åŸŸåä¸­æå–ä¸»æœºåï¼ˆå»æ‰ç«¯å£ï¼‰"""
    if ':' in domain:
        return domain.split(':')[0]
    return domain


def is_legitimate_domain(domain):
    """æ£€æŸ¥åŸŸåæ˜¯å¦ä¸ºåˆæ³•åŸŸåï¼ˆveritytech.comåŠå…¶å­åŸŸåï¼‰"""
    if not domain:
        return False
    host = get_host(domain.lower())
    return host == "veritytech.com" or host.endswith(".veritytech.com")


def extract_redirect_urls(url):
    """ä»URLå‚æ•°ä¸­æå–å¯èƒ½çš„è·³è½¬åœ°å€"""
    redirect_params = ['redirect', 'next', 'url', 'uri', 'goto', 'target', 'to', 'link', 'return', 'returnurl', 'return_url', 'redirect_uri', 'redirect_url', 'callback', 'continue', 'dest', 'destination', 'redir', 'ref', 'referer', 'referrer']
    
    redirect_urls = []
    try:
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)
        
        for param_name, values in query_params.items():
            param_lower = param_name.lower()
            if any(rp in param_lower for rp in redirect_params):
                for value in values:
                    decoded_value = unquote(value)
                    if decoded_value.startswith('http://') or decoded_value.startswith('https://'):
                        redirect_urls.append(decoded_value)
    except Exception as e:
        pass
    
    return redirect_urls


def extract_urls_from_text(text):
    """ä»æ–‡æœ¬ä¸­æå–URL"""
    url_pattern = r'https?://[a-zA-Z0-9][-a-zA-Z0-9]*(?:\.[a-zA-Z0-9][-a-zA-Z0-9]*)+(?::\d+)?(?:/[^\s<>\"\'ï¼‰\]}\u4e00-\u9fff]*)?'
    urls = re.findall(url_pattern, text)
    
    cleaned_urls = []
    for url in urls:
        url = clean_url(url)
        if url and is_valid_url(url):
            cleaned_urls.append(url)
    
    return cleaned_urls


def analyze_pdf(pdf_path):
    """åˆ†æå•ä¸ªPDFæ–‡ä»¶ï¼Œæå–æ‰€æœ‰URL"""
    urls_found = set()
    
    try:
        doc = fitz.open(pdf_path)
        
        for page_num in range(len(doc)):
            page = doc[page_num]
            
            # 1. æå–æ–‡æœ¬ä¸­çš„URL
            text = page.get_text()
            text_urls = extract_urls_from_text(text)
            urls_found.update(text_urls)
            
            # 2. æå–Annotationä¸­çš„URL
            annotations = page.annots()
            if annotations:
                for annot in annotations:
                    try:
                        info = annot.info
                        if 'uri' in info:
                            url = clean_url(info['uri'])
                            if url and is_valid_url(url):
                                urls_found.add(url)
                    except:
                        pass
            
            # 3. æå–é“¾æ¥ï¼ˆLink annotationsï¼‰
            links = page.get_links()
            for link in links:
                if 'uri' in link:
                    url = clean_url(link['uri'])
                    if url and is_valid_url(url):
                        urls_found.add(url)
        
        doc.close()
    except Exception as e:
        print(f"Error processing {pdf_path}: {e}")
    
    return urls_found


def main():
    pdf_dir = r"c:\Users\33113\Desktop\æ•°ä¿¡æ¯\æ–‡æ¡£å®‰å…¨äº‹ä»¶åˆ†æ\decrypted_pdfs"
    
    all_urls = set()
    url_sources = {}  # è®°å½•æ¯ä¸ªURLçš„æ¥æº
    
    pdf_files = [f for f in os.listdir(pdf_dir) if f.endswith('.pdf')]
    print(f"å…±å‘ç° {len(pdf_files)} ä¸ªPDFæ–‡ä»¶")
    
    for i, pdf_file in enumerate(pdf_files):
        if (i + 1) % 100 == 0:
            print(f"æ­£åœ¨å¤„ç†: {i + 1}/{len(pdf_files)}")
        
        pdf_path = os.path.join(pdf_dir, pdf_file)
        urls = analyze_pdf(pdf_path)
        
        for url in urls:
            all_urls.add(url)
            if url not in url_sources:
                url_sources[url] = []
            url_sources[url].append(pdf_file)
    
    print(f"\nå…±å‘ç° {len(all_urls)} ä¸ªURL")
    
    # åˆ†æURLï¼Œæ‰¾å‡ºéveritytech.comåŸŸåçš„URL
    non_legitimate_urls = set()
    
    for url in all_urls:
        domain = extract_domain(url)
        
        if is_legitimate_domain(domain):
            # åˆæ³•åŸŸåï¼Œä½†éœ€è¦æ£€æŸ¥å‚æ•°ä¸­çš„è·³è½¬åœ°å€
            redirect_urls = extract_redirect_urls(url)
            for redirect_url in redirect_urls:
                redirect_url_clean = clean_url(redirect_url)
                if redirect_url_clean and is_valid_url(redirect_url_clean):
                    redirect_domain = extract_domain(redirect_url_clean)
                    if redirect_domain and not is_legitimate_domain(redirect_domain):
                        non_legitimate_urls.add(redirect_url_clean)
        else:
            # éåˆæ³•åŸŸå
            if domain:
                non_legitimate_urls.add(url)
    
    print(f"å…±å‘ç° {len(non_legitimate_urls)} ä¸ªéæ³•URL")
    
    # æŒ‰å­—å…¸åºæ’åº
    sorted_urls = sorted(non_legitimate_urls)
    
    # æ‰“å°æ‰€æœ‰éæ³•URLåŠå…¶æ¥æº
    print("\néæ³•URLåˆ—è¡¨åŠæ¥æº:")
    for url in sorted_urls:
        sources = url_sources.get(url, [])
        # æ£€æŸ¥æ˜¯å¦æ¥è‡ªè·³è½¬å‚æ•°
        is_redirect = False
        for full_url in all_urls:
            if is_legitimate_domain(extract_domain(full_url)):
                redirect_urls = extract_redirect_urls(full_url)
                if url in [clean_url(r) for r in redirect_urls]:
                    is_redirect = True
                    sources = url_sources.get(full_url, [])
                    break
        
        if is_redirect:
            print(f"  {url} (æ¥è‡ªè·³è½¬å‚æ•°, æºæ–‡ä»¶: {sources[:2]}...)")
        else:
            print(f"  {url} (æºæ–‡ä»¶: {sources[:2]}...)")
    
    # ç”¨é€—å·æ‹¼æ¥
    joined_string = ",".join(sorted_urls)
    print(f"\næ‹¼æ¥åçš„å­—ç¬¦ä¸²:")
    print(joined_string)
    
    # è®¡ç®—MD5
    md5_hash = hashlib.md5(joined_string.encode('utf-8')).hexdigest()
    print(f"\nMD5 (32ä½å°å†™): {md5_hash}")
    
    return sorted_urls, md5_hash


if __name__ == "__main__":
    main()

```

MD5 (32ä½å°å†™): e5d7a8f4928cf5bb60df13dad400adbb

## æ•°æ®å­˜å‚¨

### æ•°æ®å­˜å‚¨1

#### é¢˜ç›®

å·¥ç¨‹å¸ˆå°ç‹ä¸ºäº†ä¿è¯æ•°æ®çš„å®‰å…¨å­˜å‚¨ï¼Œå¼€å‘äº†å¯¹æ•°æ®å¤„ç†çš„ç¨‹åºï¼Œä½†è¿™æ ·çš„å¤„ç†æ–¹å¼å®‰å…¨å—?åˆ†æç¨‹åºåŠŸèƒ½ï¼Œè§£å¯†æ–‡ä»¶è·å–åŸå§‹æ•°æ®ï¼Œæäº¤ç¬¬6è¡Œç¬¬2åˆ—æ•°æ®ã€‚

ç»™äº†re87a57766æ–‡ä»¶å’Œinfo_19ff9a2.ori.enæ–‡ä»¶ï¼Œè§£å¯†info_19ff9a2.ori.enï¼Œæäº¤ç¬¬å…­è¡Œç¬¬äºŒåˆ—

#### è§£ç­”

æœ¬é¢˜æ˜¯ä¸ºç¬¬äºŒé¢˜åšé“ºå«çš„

ç›´æ¥ida

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260102003941.png)

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260102004017.png)

ä¸­è½¬å‡½æ•°ï¼Œçœ‹sub_401249

```c
char *__fastcall sub_401249(unsigned __int8 *a1, int a2, unsigned int *a3)
{
  unsigned __int8 *v4; // rax
  unsigned int v5; // eax
  int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned __int8 *v11; // [rsp+10h] [rbp-18h]
  unsigned int v12; // [rsp+1Ch] [rbp-Ch]
  unsigned int v13; // [rsp+1Ch] [rbp-Ch]
  int v14; // [rsp+20h] [rbp-8h]
  int v15; // [rsp+24h] [rbp-4h]
  int v16; // [rsp+24h] [rbp-4h]
  int v17; // [rsp+24h] [rbp-4h]

  v11 = a1;
  v15 = 0;
  v14 = 0;
  v12 = 0;
  if ( !a1 )
    return 0;
  if ( !dword_4042A0 )
    sub_4011D6();
  while ( 1 )
  {
    v6 = a2--;
    if ( !v6 || v12 > 0xFFFFFFFB )
      break;
    v4 = v11++;
    v16 = *v4 + v15;
    if ( ++v14 == 3 )
    {
      byte_4042A4[v12] = byte_402020[v16 >> 18];
      byte_4042A4[v12 + 1] = byte_402020[(v16 >> 12) & 0x3F];
      byte_4042A4[v12 + 2] = byte_402020[(v16 >> 6) & 0x3F];
      v5 = v12 + 3;
      v12 += 4;
      byte_4042A4[v5] = byte_402020[v16 & 0x3F];
      v15 = 0;
      v14 = 0;
    }
    else
    {
      v15 = v16 << 8;
    }
  }
  if ( v14 )
  {
    v17 = v15 << (8 * (2 - v14));
    byte_4042A4[v12] = byte_402020[v17 >> 18];
    byte_4042A4[v12 + 1] = byte_402020[(v17 >> 12) & 0x3F];
    v7 = v12 + 2;
    v13 = v12 + 3;
    if ( v14 == 1 )
      byte_4042A4[v7] = 61;
    else
      byte_4042A4[v7] = byte_402020[(v17 >> 6) & 0x3F];
    v8 = v13;
    v12 = v13 + 1;
    byte_4042A4[v8] = 61;
  }
  byte_4042A4[v12] = 0;
  *a3 = v12;
  return byte_4042A4;
}
```

è¿™æ˜¯ä¸€ä¸ªbase64ç¼–ç å‡½æ•°

æ€»ç»“ï¼šre87a57766æ˜¯ä¸ªELFå¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¯»å–info_19ff9a2.oriæ–‡ä»¶ï¼Œbase64ç¼–ç å…¶å†…å®¹åï¼Œè¾“å‡ºä¸ºinfo_19ff9a2.ori.enc

![image](https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20260102004333.png)

### æ•°æ®å­˜å‚¨2ï¼ˆæ²¡åšå‡ºæ¥ï¼‰

#### é¢˜ç›®

å·¥ç¨‹å¸ˆå°ç‹è®¤è¯†åˆ°å‰é¢å¼€å‘çš„ç¨‹åºå¹¶ä¸èƒ½ä¿è¯å¯¹æ•°æ®çš„å®‰å…¨å­˜å‚¨ï¼Œç°åœ¨å¯¹å¤„ç†ç¨‹åºè¿›è¡Œäº†æ”¹è¿›ï¼Œè¿™æ¬¡èƒ½è¡Œå—?åˆ†æç¨‹åºåŠŸèƒ½ï¼Œè§£å¯†æ–‡ä»¶è·å–åŸå§‹æ•°æ®ï¼Œæäº¤ç¬¬8è¡Œç¬¬2åˆ—æ•°æ®ã€‚

ç±»ä¼¼ä¸Šé¢˜ï¼ŒåŠ å¯†æ–¹å¼å˜äº†

#### è§£ç­”

â€

## æ•°æ®è§£å¯†

### é¢˜ç›®

```python
import os
from Crypto.Util.number import *
from Crypto.Cipher import AES
from secret import flag, key
from Crypto.Util.Padding import pad

assert(len(flag) == 38)
assert flag[:5] == b'flag{' and flag[-1:] == b'}'
assert(len(key) == 16)

flag='flag{IADMIN-TOP-18880101-7634567_2025}'
def padding(msg):
    tmp = 16 - len(msg) % 16
    pad = format(tmp, '02x')
    return bytes.fromhex(pad * tmp) + msg
message = padding(flag)
hint = bytes_to_long(key) ^ bytes_to_long(message[:16])
message = pad(message, 16, 'pkcs7')
print(message)
IV = os.urandom(16)
encryption = AES.new(key, AES.MODE_CBC, iv=IV)
enc = encryption.encrypt(message)

print('enc =', enc.hex())
print('hint =', hex(hint)[2:])

# enc = 1ce1df3812668ce0bccd86c146cc56989681e128edd0676f5d26e01abdee90c860e22a5a491f94ac5ca3ab02242740fb8c35a3b60ea737ca0d2662fba2b0e299
# hint = 32393f4e3c3c4f3e323a512a5356437d
```

*åæ§½ï¼šè¿™é¢˜æ˜¯é•¿äº­å‡ºçš„å§ï¼Œè·Ÿæˆ‘ä¸€ä¸ªæœˆå‰åšçš„sm4ç‰ˆæœ¬ä¸€æ¨¡ä¸€æ ·*

### è§£ç­”

```python
def padding(msg):
    tmp = 16 - len(msg) % 16
    pad = format(tmp, '02x')
    return bytes.fromhex(pad * tmp) + msg

msg1 = "flag{0123456789abcdef0123456789abcdef}"
msg2 = padding(msg1.encode())
print(msg2)
msg3 = pad(msg2 , 16, 'pkcs7')
print(padding(msg3))
```

è‡ªå·±ç¼–ä¸€ç‚¹æ•°æ®çœ‹çœ‹å¡«å……æ•ˆæœ

```python
b'\n\n\n\n\n\n\n\n\n\nflag{0123456789abcdef0123456789abcdef}'
b'\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\n\n\n\n\n\n\n\n\n\nflag{0123456789abcdef0123456789abcdef}\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10'
```

å¯çŸ¥hint=â€˜\n\n\n\n\n\n\n\n\n\nflag{?' ^ key

å¯é€šè¿‡çˆ†ç ´æœ€åä¸€ä½çš„å€¼ï¼Œå°è¯•å“ªä¸ªkeyæ˜¯å¯¹çš„

```python
c1 = enc(k,p1^iv)
c2 = enc(k,p2^c1)
c3 = enc(k,p3^c2)

p3 = dec(k,c3)^c2
p2 = dec(k,c2)^c1
p1 = dec(k,c1)^iv
```

æ ¹æ®cbcçš„åŠ å¯†æ–¹å¼ç‰¹å¾ï¼Œivä¸çŸ¥é“çš„æƒ…å†µä¸‹ï¼Œä¸å½±å“è§£å¯†p2ï¼Œp3ç­‰åç»­å¯†æ–‡

æ ¹æ®flagçš„ç‰¹å¾å¯çŸ¥ï¼Œæ˜æ–‡çš„ç»“å°¾æ˜¯ç‰¹å¾æ˜¯  }\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10

å› æ­¤åœ¨çˆ†ç ´çš„æ—¶å€™ï¼Œçœ‹å“ªä¸ªkeyå¯ä»¥æ»¡è¶³è¯¥ç‰¹å¾

```python
import hashlib
from Crypto.Cipher import AES
import os
import string
from Crypto.Util.number import *
from Crypto.Util.Padding import pad

enc = '1ce1df3812668ce0bccd86c146cc56989681e128edd0676f5d26e01abdee90c860e22a5a491f94ac5ca3ab02242740fb8c35a3b60ea737ca0d2662fba2b0e299'
hint = '32393f4e3c3c4f3e323a512a5356437d'

"""
c1 = enc(k,p1^iv)
c2 = enc(k,p2^c1)
c3 = enc(k,p3^c2)

p3 = dec(k,c3)^c2
p2 = dec(k,c2)^c1
p1 = dec(k,c1)^iv

"""

'''
flag = 6+16+16
flag{? 5ä½ï¼Œè¿˜å·®ä¸€ä½
} ç»“å°¾
'''

def padding(msg):
    tmp = 16 - len(msg) % 16
    pad = format(tmp, '02x')
    return bytes.fromhex(pad * tmp) + msg

msg1 = "flag{0123456789abcdef0123456789abcdef}"
msg2 = padding(msg1.encode())
print(msg2)
msg3 = pad(msg2 , 16, 'pkcs7')
print(padding(msg3))


enc_b = bytes.fromhex(enc) # 64
hint_b = bytes.fromhex(hint)

IV_fake = os.urandom(16)
for char in string.ascii_letters + string.digits:
    # print("flag{"+char)
    test_msg = '\n\n\n\n\n\n\n\n\n\nflag{'+char
    # print(test.encode())
    test_key = long_to_bytes(bytes_to_long(hint_b) ^ bytes_to_long(test_msg.encode()))

    encryption = AES.new(test_key, AES.MODE_CBC, iv=IV_fake)

    p = encryption.decrypt(enc_b)
    if '}\\x10' in str(p):
        print(p)
        print(test_msg)


# flag{IADMIN-TOP-18880101-7634567_2025}
```

## æ•°æ®éšè—

### é¢˜ç›®

æŸæ±½è½¦ä¾›åº”é“¾ç‰©æµä¸­å°æ­£åœ¨è¿›è¡Œå­£åº¦æ•°æ®å½’æ¡£ï¼Œç”±äºå½’æ¡£ä»»åŠ¡å ç”¨äº†ä¸»ç´¢å¼•èµ„æºï¼Œè¿ç»´å›¢é˜Ÿå¯ç”¨äº†ä¸€å¥—â€œåº•å±‚åº”æ€¥ç´¢å¼•æœºåˆ¶â€ã€‚è¯¥æœºåˆ¶å¹¶ä¸ä¾èµ– SOLite åŸç”Ÿçš„ç´¢å¼•ï¼Œè€Œæ˜¯è®¾è®¡äº†ä¸€å¥—è‡ªå®šä¹‰çš„è·¨é¡µé“¾è¡¨åè®®ï¼Œå°†å…³é”®ç­›é€‰é€»è¾‘ç¢ç‰‡åŒ–åœ°å­˜å‚¨åœ¨æ•°æ®åº“æ–‡ä»¶çš„ç‰©ç†ç©ºé—²å— (Freeblocks) æ•°æ®åŒºä¸­ã€‚ è¯·æ£€æŸ» sys_config è¡¨ï¼Œè·å–åº•å±‚é“¾è¡¨çš„å…¥å£æŒ‡é’ˆä»¥åŠè‡ªå®šä¹‰é“¾è¡¨èŠ‚ç‚¹çš„ç»“æ„å®šä¹‰ã€‚æ ¹æ®ç»“æ„å®šä¹‰ï¼Œä»åº•å±‚ç‰©ç†ç©ºé—´ä¸­æå–å¹¶é‡ç»„å‡ºâ€œç‰¹å®šæ‰¹æ¬¡è´§ç‰©ç­›é€‰è„šæœ¬â€(SQL)ã€‚éšå†™æ•°æ®ä½äº SQLite Freeblock çš„æœ‰æ•ˆè½½è·åŒº(è·³è¿‡ Freeblock è‡ªèº«çš„4å­—èŠ‚å¤´éƒ¨)ã€‚æ•°æ®ç»è¿‡äº†å¼‚æˆ–å¤„ç†ï¼Œå¯†é’¥ä¸æ‰€åœ¨ç‰©ç†é¡µå·æœ‰å…³ã€‚è¿è¡Œæå–å‡ºçš„è„šæœ¬ï¼Œå®šä½å‡ºè¯¥æ‰¹æ¬¡é›·è¾¾æ¨¡ç»„æ‰€åœ¨çš„ é›†è£…ç®±ç¼–å·(containerid)å’Œè½¦ç‰Œå·(license_plate)ï¼Œæœ€ç»ˆéœ€è¦å°† container_id å’Œlicense_plate çš„åäº”ä½æ•°å­—ä½¿ç”¨ä¸‹åˆ’çº¿è¿æ¥æäº¤ï¼Œä¾‹å¦‚:CN2877541671_72345ã€‚

### è§£ç­”

â€
